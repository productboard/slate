{"version":3,"file":"slate.js","sources":["../src/utils/key-utils.js","../src/models/data.js","../src/models/document.js","../src/models/inline.js","../src/models/mark.js","../src/models/leaf.js","../src/utils/memoize.js","../src/models/text.js","../src/models/node.js","../src/models/block.js","../src/utils/path-utils.js","../src/models/point.js","../src/models/decoration.js","../src/utils/is-object.js","../src/models/range.js","../src/models/selection.js","../src/models/value.js","../src/operations/apply.js","../src/operations/invert.js","../src/models/operation.js","../src/controllers/change.js","../src/commands/at-current-range.js","../src/utils/text-utils.js","../src/commands/at-range.js","../src/commands/by-path.js","../src/plugins/commands.js","../src/commands/on-history.js","../src/commands/on-selection.js","../src/commands/on-value.js","../src/plugins/queries.js","../src/utils/slate-error.js","../src/plugins/schema.js","../src/plugins/core.js","../src/controllers/editor.js","../src/utils/mixin.js","../src/interfaces/object.js","../src/interfaces/model.js","../src/interfaces/node.js","../src/interfaces/element.js","../src/interfaces/range.js","../src/index.js"],"sourcesContent":["/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate()\n  }\n\n  if (typeof key === 'string') {\n    return key\n  }\n\n  throw new Error(`Keys must be strings, but you passed: ${key}`)\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  create,\n  setGenerator,\n  resetGenerator,\n}\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport { Map, Record, Set } from 'immutable'\n\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import isPlainObject from 'is-plain-object'\nimport { List, Record, Set } from 'immutable'\n\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: undefined,\n  text: undefined,\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a valid List of `Leaf` from `leaves`\n   *\n   * @param {List<Leaf>} leaves\n   * @return {List<Leaf>}\n   */\n\n  static createLeaves(leaves) {\n    if (leaves.size <= 1) return leaves\n\n    let invalid = false\n\n    // TODO: we can make this faster with [List] and then flatten\n    const result = List().withMutations(cache => {\n      // Search from the leaves left end to find invalid node;\n      leaves.findLast((leaf, index) => {\n        const firstLeaf = cache.first()\n\n        // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n        if (firstLeaf) {\n          // If marks equals, then the two leaves can be connected\n          if (firstLeaf.marks.equals(leaf.marks)) {\n            invalid = true\n            cache.set(0, firstLeaf.set('text', `${leaf.text}${firstLeaf.text}`))\n            return\n          }\n\n          // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n          if (firstLeaf.text === '') {\n            invalid = true\n            cache.set(0, leaf)\n            return\n          }\n\n          // If the current leaf is empty, drop the leaf\n          if (leaf.text === '') {\n            invalid = true\n            return\n          }\n        }\n\n        cache.unshift(leaf)\n      })\n    })\n\n    if (!invalid) return leaves\n    return result\n  }\n\n  /**\n   * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n   * Corner Cases:\n   *   1. if offset is smaller than 0, then return [List(), leaves]\n   *   2. if offset is bigger than the text length, then return [leaves, List()]\n   *\n   * @param {List<Leaf> leaves\n   * @return {Array<List<Leaf>>}\n   */\n\n  static splitLeaves(leaves, offset) {\n    if (offset < 0) return [List(), leaves]\n\n    if (leaves.size === 0) {\n      return [List(), List()]\n    }\n\n    let endOffset = 0\n    let index = -1\n    let left, right\n\n    leaves.find(leaf => {\n      index++\n      const startOffset = endOffset\n      const { text } = leaf\n      endOffset += text.length\n\n      if (endOffset < offset) return false\n      if (startOffset > offset) return false\n\n      const length = offset - startOffset\n      left = leaf.set('text', text.slice(0, length))\n      right = leaf.set('text', text.slice(length))\n      return true\n    })\n\n    if (!left) return [leaves, List()]\n\n    if (left.text === '') {\n      if (index === 0) {\n        return [List.of(left), leaves]\n      }\n\n      return [leaves.take(index), leaves.skip(index)]\n    }\n\n    if (right.text === '') {\n      if (index === leaves.size - 1) {\n        return [leaves, List.of(right)]\n      }\n\n      return [leaves.take(index + 1), leaves.skip(index + 1)]\n    }\n\n    return [\n      leaves.take(index).push(left),\n      leaves.skip(index + 1).unshift(right),\n    ]\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Update a `mark` at leaf, replace with newMark\n   *\n   * @param {Mark} mark\n   * @param {Mark} newMark\n   * @returns {Leaf}\n   */\n\n  updateMark(mark, newMark) {\n    const { marks } = this\n    if (newMark.equals(mark)) return this\n    if (!marks.has(mark)) return this\n    const newMarks = marks.withMutations(collection => {\n      collection.remove(mark).add(newMark)\n    })\n    return this.set('marks', newMarks)\n  }\n\n  /**\n   * Add a `mark` to the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  addMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.add(mark))\n  }\n\n  /**\n   * Add a `set` of marks to the leaf.\n   *\n   * @param {Set<Mark>} set\n   * @returns {Text}\n   */\n\n  addMarks(set) {\n    const { marks } = this\n    return this.set('marks', marks.union(set))\n  }\n\n  /**\n   * Insert a text `string` into the leaf at `offset`.\n   *\n   * @param {Number} offset\n   * @param {String} string\n   * @return {Leaf}\n   */\n\n  insertText(offset, string) {\n    const { text } = this\n    const next = text.slice(0, offset) + string + text.slice(offset)\n    return this.set('text', next)\n  }\n\n  /**\n   * Remove a `mark` from the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  removeMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.remove(mark))\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n *\n * @type {Number}\n */\n\nlet CACHE_KEY = 0\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nconst LEAF = {}\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nconst UNDEFINED = {}\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args)\n\n      // If the cache key is different, previous caches must be cleared.\n      if (CACHE_KEY !== this.__cache_key) {\n        this.__cache_key = CACHE_KEY\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n        this.__cache_no_args = {}\n      }\n\n      if (!this.__cache) {\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      }\n\n      if (!this.__cache_no_args) {\n        this.__cache_no_args = {}\n      }\n\n      const takesArguments = args.length !== 0\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(this.__cache, keys)\n      } else {\n        cachedValue = this.__cache_no_args[property]\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v)\n      } else {\n        this.__cache_no_args[property] = v\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (const key of keys) {\n    map = map.get(key)\n    if (map === UNSET) return UNSET\n  }\n\n  return map.get(LEAF)\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let parent = map\n  let child\n\n  for (const key of keys) {\n    child = parent.get(key)\n\n    // If the path was not created yet...\n    if (child === UNSET) {\n      child = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      parent.set(key, child)\n    }\n\n    parent = child\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child.set(LEAF, value)\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  CACHE_KEY++\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List, OrderedSet, Record, Set } from 'immutable'\n\nimport Leaf from './leaf'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  leaves: undefined,\n  key: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { leaves: [{ text: attrs }] }\n    }\n\n    if (isPlainObject(attrs)) {\n      if (attrs.text) {\n        const { text, marks, key } = attrs\n        attrs = { key, leaves: [{ text, marks }] }\n      }\n\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    const { key = KeyUtils.create() } = object\n    let { leaves } = object\n\n    if (!leaves) {\n      if (object.ranges) {\n        warning(\n          false,\n          'As of slate@0.27.0, the `ranges` property of Slate objects has been renamed to `leaves`.'\n        )\n\n        leaves = object.ranges\n      } else {\n        leaves = List()\n      }\n    }\n\n    if (Array.isArray(leaves)) {\n      leaves = List(leaves.map(x => Leaf.create(x)))\n    } else if (List.isList(leaves)) {\n      leaves = leaves.map(x => Leaf.create(x))\n    } else {\n      throw new Error('leaves must be either Array or Immutable.List')\n    }\n\n    const node = new Text({\n      leaves: Leaf.createLeaves(leaves),\n      key,\n    })\n\n    return node\n  }\n\n  /**\n   * Check if `any` is a listÂ of texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Find the 'first' leaf at offset; By 'first' the alorighthm prefers `endOffset === offset` than `startOffset === offset`\n   * Corner Cases:\n   *   1. if offset is negative, return the first leaf;\n   *   2. if offset is larger than text length, the leaf is null, startOffset, endOffset and index is of the last leaf\n   *\n   * @param {number}\n   * @returns {Object}\n   *   @property {number} startOffset\n   *   @property {number} endOffset\n   *   @property {number} index\n   *   @property {Leaf} leaf\n   */\n\n  searchLeafAtOffset(offset) {\n    let endOffset = 0\n    let startOffset = 0\n    let index = -1\n\n    const leaf = this.leaves.find(l => {\n      index++\n      startOffset = endOffset\n      endOffset = startOffset + l.text.length\n      return endOffset >= offset\n    })\n\n    return {\n      leaf,\n      endOffset,\n      index,\n      startOffset,\n    }\n  }\n\n  /**\n   * Add a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(index, length, mark) {\n    const marks = Set.of(mark)\n    return this.addMarks(index, length, marks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   * Corner Cases:\n   *   1. If empty text, and if length === 0 and index === 0, will make sure the text contain an empty leaf with the given mark.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Set<Mark>} set\n   * @return {Text}\n   */\n\n  addMarks(index, length, set) {\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n\n      if (!first) {\n        return this.set(\n          'leaves',\n          List.of(Leaf.fromJSON({ text: '', marks: set }))\n        )\n      }\n\n      const newFirst = first.addMarks(set)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (this.text === '') return this\n    if (length === 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.addMarks(set)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Derive the leaves for a list of `decorations`.\n   *\n   * @param {Array|Void} decorations (optional)\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations = []) {\n    let { leaves } = this\n    if (leaves.size === 0) return List.of(Leaf.create({}))\n    if (!decorations || decorations.length === 0) return leaves\n    if (this.text.length === 0) return leaves\n    const { key } = this\n\n    decorations.forEach(dec => {\n      const { start, end, mark } = dec\n      const hasStart = start.key == key\n      const hasEnd = end.key == key\n\n      if (hasStart && hasEnd) {\n        const index = hasStart ? start.offset : 0\n        const length = hasEnd ? end.offset - index : this.text.length - index\n\n        if (length < 1) return\n        if (index >= this.text.length) return\n\n        if (index !== 0 || length < this.text.length) {\n          const [before, bundle] = Leaf.splitLeaves(leaves, index)\n          const [middle, after] = Leaf.splitLeaves(bundle, length)\n          leaves = before.concat(middle.map(x => x.addMark(mark)), after)\n          return\n        }\n      }\n\n      leaves = leaves.map(x => x.addMark(mark))\n    })\n\n    if (leaves === this.leaves) return leaves\n    return Leaf.createLeaves(leaves)\n  }\n\n  /**\n   * Get all of the active marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getActiveMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.intersect(leaf.marks)\n      if (result && result.size === 0) return false\n      return false\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the active marks on the text\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarks() {\n    if (this.leaves.size === 0) return Set()\n\n    const result = this.leaves.first().marks\n    if (result.size === 0) return result\n\n    return result.toOrderedSet().withMutations(x => {\n      this.leaves.forEach(c => {\n        x.intersect(c.marks)\n        if (x.size === 0) return false\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.union(leaf.marks)\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the marks on the text.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks on the text as an array\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    if (this.leaves.size === 0) return []\n    const first = this.leaves.first().marks\n    if (this.leaves.size === 1) return first.toArray()\n\n    const result = []\n\n    this.leaves.forEach(leaf => {\n      result.push(leaf.marks.toArray())\n    })\n\n    return Array.prototype.concat.apply(first.toArray(), result)\n  }\n\n  /**\n   * Get the marks on the text at `index`.\n   * Corner Cases:\n   *   1. if no text is before the index, and index !== 0, then return Set()\n   *   2. (for insert after split node or mark at range) if index === 0, and text === '', then return the leaf.marks\n   *   3. if index === 0, text !== '', return Set()\n   *\n   *\n   * @param {Number} index\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtIndex(index) {\n    const { leaf } = this.searchLeafAtOffset(index)\n    if (!leaf) return Set()\n    return leaf.marks\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Numbder} offset\n   * @param {String} text\n   * @param {Set} marks (optional)\n   * @return {Text}\n   */\n\n  insertText(offset, text, marks) {\n    if (this.text === '') {\n      return this.set('leaves', List.of(Leaf.create({ text, marks })))\n    }\n\n    if (text.length === 0) return this\n    if (!marks) marks = Set()\n\n    const { startOffset, leaf, index } = this.searchLeafAtOffset(offset)\n    const delta = offset - startOffset\n    const beforeText = leaf.text.slice(0, delta)\n    const afterText = leaf.text.slice(delta)\n    const { leaves } = this\n\n    if (leaf.marks.equals(marks)) {\n      return this.set(\n        'leaves',\n        leaves.set(index, leaf.set('text', beforeText + text + afterText))\n      )\n    }\n\n    const nextLeaves = leaves.splice(\n      index,\n      1,\n      leaf.set('text', beforeText),\n      Leaf.create({ text, marks }),\n      leaf.set('text', afterText)\n    )\n\n    return this.setLeaves(nextLeaves)\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(index, length, mark) {\n    if (this.text === '' && index === 0 && length === 0) {\n      const first = this.leaves.first()\n      if (!first) return this\n      const newFirst = first.removeMark(mark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.removeMark(mark)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Remove text from the text node at `start` for `length`.\n   *\n   * @param {Number} start\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(start, length) {\n    if (length <= 0) return this\n    if (start >= this.text.length) return this\n\n    // PERF: For simple backspace, we can operate directly on the leaf\n    if (length === 1) {\n      const { leaf, index, startOffset } = this.searchLeafAtOffset(start + 1)\n      const offset = start - startOffset\n\n      if (leaf) {\n        if (leaf.text.length === 1) {\n          const leaves = this.leaves.remove(index)\n          return this.setLeaves(leaves)\n        }\n\n        const beforeText = leaf.text.slice(0, offset)\n        const afterText = leaf.text.slice(offset + length)\n        const text = beforeText + afterText\n\n        if (text.length > 0) {\n          return this.set(\n            'leaves',\n            this.leaves.set(index, leaf.set('text', text))\n          )\n        }\n      }\n    }\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, start)\n    const after = Leaf.splitLeaves(bundle, length)[1]\n    const leaves = Leaf.createLeaves(before.concat(after))\n\n    if (leaves.size === 1) {\n      const first = leaves.first()\n\n      if (first.text === '') {\n        return this.set(\n          'leaves',\n          List.of(first.set('marks', this.getActiveMarks()))\n        )\n      }\n    }\n\n    return this.set('leaves', leaves)\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      leaves: this.getLeaves()\n        .toArray()\n        .map(r => r.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Update a `mark` at `index` and `length` with `properties`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Text}\n   */\n\n  updateMark(index, length, mark, properties) {\n    const newMark = mark.merge(properties)\n\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n      if (!first) return this\n      const newFirst = first.updateMark(mark, newMark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n\n    const leaves = before.concat(\n      middle.map(x => x.updateMark(mark, newMark)),\n      after\n    )\n\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Split this text and return two different texts\n   * @param {Number} position\n   * @returns {Array<Text>}\n   */\n\n  splitText(offset) {\n    const splitted = Leaf.splitLeaves(this.leaves, offset)\n    const one = this.set('leaves', splitted[0])\n    const two = this.set('leaves', splitted[1]).regenerateKey()\n    return [one, two]\n  }\n\n  /**\n   * merge this text and another text at the end\n   * @param {Text} text\n   * @returns {Text}\n   */\n\n  mergeText(text) {\n    const leaves = this.leaves.concat(text.leaves)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Set leaves with normalized `leaves`\n   *\n   * @param {List} leaves\n   * @returns {Text}\n   */\n\n  setLeaves(leaves) {\n    const result = Leaf.createLeaves(leaves)\n\n    if (result.size === 1) {\n      const first = result.first()\n\n      if (!first.marks || first.marks.size === 0) {\n        if (first.text === '') {\n          return this.set('leaves', List())\n        }\n      }\n    }\n\n    return this.set('leaves', Leaf.createLeaves(leaves))\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, ['getActiveMarks', 'getMarks', 'getMarksAsArray'])\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport Block from './block'\nimport Data from './data'\nimport Document from './document'\nimport Inline from './inline'\nimport Text from './text'\n\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        warning(\n          false,\n          'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n        )\n\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = List(elements.map(Node.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      warning(\n        false,\n        'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n      )\n\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return (\n      Block.isBlock(any) ||\n      Document.isDocument(any) ||\n      Inline.isInline(any) ||\n      Text.isText(any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      data: Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","import { List } from 'immutable'\n\n/**\n * Compare paths `path` and `target` to see which is before or after.\n *\n * @param {List} path\n * @param {List} target\n * @return {Number|Null}\n */\n\nfunction compare(path, target) {\n  const m = min(path, target)\n\n  for (let i = 0; i < m; i++) {\n    const pv = path.get(i)\n    const tv = target.get(i)\n\n    // If the path's value is ever less than the target's, it's before.\n    if (pv < tv) return -1\n\n    // If the target's value is ever less than the path's, it's after.\n    if (pv > tv) return 1\n  }\n\n  // Paths should now be equal, otherwise something is wrong\n  return path.size === target.size ? 0 : null\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create(attrs) {\n  if (attrs == null) {\n    return null\n  }\n\n  if (List.isList(attrs)) {\n    return attrs\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs)\n  }\n\n  throw new Error(\n    `Paths can only be created from arrays or lists, but you passed: ${attrs}`\n  )\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b, size = min(a, b)) {\n  const ca = a.slice(0, size)\n  const cb = b.slice(0, size)\n  return [ca, cb]\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path, n = 1, index = path.size - 1) {\n  return increment(path, 0 - n, index)\n}\n\n/**\n * Get all ancestor paths of th given path.\n *\n * @param {List} path\n * @returns {List}\n */\n\nfunction getAncestors(path) {\n  let ancestors = new List()\n\n  for (let i = 0; i < path.size; i++) {\n    ancestors = ancestors.push(path.slice(0, i))\n  }\n\n  return ancestors\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path, n = 1, index = path.size - 1) {\n  const value = path.get(index)\n  const newValue = value + n\n  const newPath = path.set(index, newValue)\n  return newPath\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  const [p, t] = crop(path, target)\n  return path.size < target.size && compare(p, t) === 0\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === 1\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === -1\n}\n\n/**\n * Is a `path` equal to another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isEqual(path, target) {\n  return path.equals(target)\n}\n\n/**\n * Is a `path` older than a `target` path? Meaning that it ends as an older\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isOlder(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl > tl\n}\n\n/**\n * Is a `path` a sibling of a `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isSibling(path, target) {\n  if (path.size !== target.size) return false\n  const p = path.butLast()\n  const t = target.butLast()\n  return p.equals(t)\n}\n\n/**\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isYounger(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl < tl\n}\n\n/**\n * Lift a `path` to refer to its parent.\n *\n * @param {List} path\n * @return {Array}\n */\n\nfunction lift(path) {\n  const parent = path.slice(0, -1)\n  return parent\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  const n = Math.max(a.size, b.size)\n  return n\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  const n = Math.min(a.size, b.size)\n  return n\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  const array = []\n\n  for (let i = 0; i < a.size && i < b.size; i++) {\n    const av = a.get(i)\n    const bv = b.get(i)\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av)\n  }\n\n  const path = create(array)\n  return path\n}\n\n/**\n * Transform a `path` by an `operation`, adjusting it to stay current.\n *\n * @param {List} path\n * @param {Operation} operation\n * @return {List<List>}\n */\n\nfunction transform(path, operation) {\n  const { type, position, path: p } = operation\n\n  if (\n    type === 'add_mark' ||\n    type === 'insert_text' ||\n    type === 'remove_mark' ||\n    type === 'remove_text' ||\n    type === 'set_mark' ||\n    type === 'set_node' ||\n    type === 'set_selection' ||\n    type === 'set_value' ||\n    path.size === 0\n  ) {\n    return List([path])\n  }\n\n  const pIndex = p.size - 1\n  const pEqual = isEqual(p, path)\n  const pYounger = isYounger(p, path)\n  const pAbove = isAbove(p, path)\n\n  if (type === 'insert_node') {\n    if (pEqual || pYounger || pAbove) {\n      path = increment(path, 1, pIndex)\n    }\n  }\n\n  if (type === 'remove_node') {\n    if (pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pEqual || pAbove) {\n      path = []\n    }\n  }\n\n  if (type === 'merge_node') {\n    if (pEqual || pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pAbove) {\n      path = decrement(path, 1, pIndex)\n      path = increment(path, position, pIndex + 1)\n    }\n  }\n\n  if (type === 'split_node') {\n    if (pEqual) {\n      path = [path, increment(path)]\n    } else if (pYounger) {\n      path = increment(path, 1, pIndex)\n    } else if (pAbove) {\n      if (path.get(pIndex + 1) >= position) {\n        path = increment(path, 1, pIndex)\n        path = decrement(path, position, pIndex + 1)\n      }\n    }\n  }\n\n  if (type === 'move_node') {\n    const { newPath: np } = operation\n    const npIndex = np.size - 1\n    const npEqual = isEqual(np, path)\n\n    if (isEqual(p, np)) {\n      return List([path])\n    }\n\n    const npYounger = isYounger(np, path)\n    const npAbove = isAbove(np, path)\n\n    if (pAbove) {\n      path = np.concat(path.slice(p.size))\n    } else {\n      if (pEqual) {\n        path = np\n      } else if (pYounger) {\n        path = decrement(path, 1, pIndex)\n      }\n\n      if (npEqual || npYounger || npAbove) {\n        path = increment(path, 1, npIndex)\n      }\n    }\n  }\n\n  const paths = Array.isArray(path) ? path : [path]\n  return List(paths)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  compare,\n  create,\n  crop,\n  decrement,\n  getAncestors,\n  increment,\n  isAbove,\n  isAfter,\n  isBefore,\n  isEqual,\n  isOlder,\n  isSibling,\n  isYounger,\n  lift,\n  max,\n  min,\n  relate,\n  transform,\n}\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  offset: undefined,\n  path: undefined,\n}\n\n/**\n * Point.\n *\n * @type {Point}\n */\n\nclass Point extends Record(DEFAULTS) {\n  /**\n   * Create a new `Point` with `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Point}\n   */\n\n  static create(attrs = {}) {\n    if (Point.isPoint(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Point.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Point.create\\` only accepts objects or points, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable point properties from `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Point.isPoint(a)) {\n      return {\n        key: a.key,\n        offset: a.offset,\n        path: a.path,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('key' in a) p.key = a.key\n      if ('offset' in a) p.offset = a.offset\n      if ('path' in a) p.path = PathUtils.create(a.path)\n\n      // If only a path is set, or only a key is set, ensure that the other is\n      // set to null so that it can be normalized back to the right value.\n      // Otherwise we won't realize that the path and key don't match anymore.\n      if ('path' in a && !('key' in a)) p.key = null\n      if ('key' in a && !('path' in a)) p.path = null\n\n      return p\n    }\n\n    throw new Error(\n      `\\`Point.createProperties\\` only accepts objects or points, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Point` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Point}\n   */\n\n  static fromJSON(object) {\n    const { key = null, offset = null, path = null } = object\n\n    const point = new Point({\n      key,\n      offset,\n      path: PathUtils.create(path),\n    })\n\n    return point\n  }\n\n  /**\n   * Check whether all properties of the point are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.key != null && this.offset != null && this.path != null\n  }\n\n  /**\n   * Check whether any property of the point is not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Check whether the point is after another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterPoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset > point.offset) ||\n      PathUtils.compare(this.path, point.path) === 1\n    return is\n  }\n\n  /**\n   * Check whether the point is after a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterRange(range) {\n    if (this.isUnset) return false\n    const is = this.isAfterPoint(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtEndOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtStartOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is before another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforePoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset < point.offset) ||\n      PathUtils.compare(this.path, point.path) === -1\n    return is\n  }\n\n  /**\n   * Check whether the point is before a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforeRange(range) {\n    if (this.isUnset) return false\n    const is = this.isBeforePoint(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is inside a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isInRange(range) {\n    if (this.isUnset) return false\n    const is =\n      this.equals(range.start) ||\n      this.equals(range.end) ||\n      (this.isAfterPoint(range.start) && this.isBeforePoint(range.end))\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOfNode(node) {\n    if (this.isUnset) return false\n    const last = node.getLastText()\n    const is = this.key === last.key && this.offset === last.text.length\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOfNode(node) {\n    if (this.isUnset) return false\n\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.offset != 0) return false\n\n    const first = node.getFirstText()\n    const is = this.key === first.key\n    return is\n  }\n\n  /**\n   * Check whether the point is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isInNode(node) {\n    if (this.isUnset) return false\n    if (node.object === 'text' && node.key === this.key) return true\n    if (node.hasNode(this.key)) return true\n    return false\n  }\n\n  /**\n   * Move the point's offset backward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveBackward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveForward(-n)\n    const point = this.setOffset(this.offset - n)\n    return point\n  }\n\n  /**\n   * Move the point's offset forward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveForward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveBackward(-n)\n    const point = this.setOffset(this.offset + n)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String|Number} path\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  moveTo(path, offset = 0) {\n    let key = this.key\n\n    if (typeof path === 'number') {\n      offset = path\n      path = this.path\n    } else if (typeof path === 'string') {\n      key = path\n      path = key === this.key ? this.path : null\n    } else {\n      key = path.equals(this.path) ? this.key : null\n    }\n\n    const point = this.merge({ key, path, offset })\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToStartOfNode(node) {\n    const first = node.getFirstText()\n    const point = this.moveTo(first.key, 0)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToEndOfNode(node) {\n    const last = node.getLastText()\n    const point = this.moveTo(last.key, last.text.length)\n    return point\n  }\n\n  /**\n   * Normalize the point relative to a `node`, ensuring that its key and path\n   * reference a text node, or that it gets unset.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  normalize(node) {\n    // If both the key and path are null, there's no reference to a node, so\n    // make sure it is entirely unset.\n    if (this.key == null && this.path == null) {\n      return this.setOffset(null)\n    }\n\n    const { key, offset, path } = this\n    const target = node.getNode(key || path)\n\n    if (!target) {\n      warning(false, \"A point's `path` or `key` invalid and was reset!\")\n\n      const text = node.getFirstText()\n      if (!text) return Point.create()\n\n      const point = this.merge({\n        key: text.key,\n        offset: 0,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target.object !== 'text') {\n      warning(false, 'A point should not reference a non-text node!')\n\n      const text = target.getTextAtOffset(offset)\n      const before = target.getOffset(text.key)\n      const point = this.merge({\n        offset: offset - before,\n        key: text.key,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target && path && key && key !== target.key) {\n      warning(false, \"A point's `key` did not match its `path`!\")\n    }\n\n    const point = this.merge({\n      key: target.key,\n      path: path == null ? node.getPath(target.key) : path,\n      offset: offset == null ? 0 : Math.min(offset, target.text.length),\n    })\n\n    return point\n  }\n\n  /**\n   * Set the point's key to a new `key`.\n   *\n   * @param {String} key\n   * @return {Point}\n   */\n\n  setKey(key) {\n    if (key !== null) {\n      key = KeyUtils.create(key)\n    }\n\n    const point = this.set('key', key)\n    return point\n  }\n\n  /**\n   * Set the point's offset to a new `offset`.\n   *\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  setOffset(offset) {\n    const point = this.set('offset', offset)\n    return point\n  }\n\n  /**\n   * Set the point's path to a new `path`.\n   *\n   * @param {List|Array} path\n   * @return {Point}\n   */\n\n  setPath(path) {\n    if (path !== null) {\n      path = PathUtils.create(path)\n    }\n\n    const point = this.set('path', path)\n    return point\n  }\n\n  /**\n   * Return a JSON representation of the point.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      key: this.key,\n      offset: this.offset,\n      path: this.path && this.path.toArray(),\n    }\n\n    if (!options.preserveKeys) {\n      delete object.key\n    }\n\n    return object\n  }\n\n  /**\n   * Unset the point.\n   *\n   * @return {Point}\n   */\n\n  unset() {\n    return this.merge({\n      key: null,\n      offset: null,\n      path: null,\n    })\n  }\n}\n\n/**\n * Export.\n *\n * @type {Point}\n */\n\nexport default Point\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n  mark: undefined,\n}\n\n/**\n * Decoration.\n *\n * @type {Decoration}\n */\n\nclass Decoration extends Record(DEFAULTS) {\n  /**\n   * Create a new `Decoration` with `attrs`.\n   *\n   * @param {Object|Decoration} attrs\n   * @return {Decoration}\n   */\n\n  static create(attrs = {}) {\n    if (Decoration.isDecoration(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Decoration.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Decoration.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Decoration.create\\` only accepts objects or decorations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n   * @return {List<Decoration>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Decoration.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Decoration.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable decoration properties from `attrs`.\n   *\n   * @param {Object|String|Decoration} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Decoration.isDecoration(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        mark: Mark.create(a.mark),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('mark' in a) p.mark = Mark.create(a.mark)\n      return p\n    }\n\n    throw new Error(\n      `\\`Decoration.createProperties\\` only accepts objects or decorations, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Decoration` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Decoration}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, mark } = object\n\n    if (!mark) {\n      throw new Error(\n        `Decorations must be created with a \\`mark\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    const decoration = new Decoration({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      mark: Mark.fromJSON(mark),\n    })\n\n    return decoration\n  }\n\n  /**\n   * Set new `properties` on the decoration.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Decoration.createProperties(properties)\n    const { anchor, focus, mark } = properties\n    const props = {}\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    if (mark) {\n      props.mark = Mark.create(mark)\n    }\n\n    const decoration = this.merge(props)\n    return decoration\n  }\n\n  /**\n   * Return a JSON representation of the decoration.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      mark: this.mark.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Decoration}\n */\n\nexport default Decoration\n","/**\n * Slate-specific object types.\n *\n * @type {Object}\n */\n\nexport const TYPES = {\n  block: '@@__SLATE_BLOCK__@@',\n  change: '@@__SLATE_CHANGE__@@',\n  decoration: '@@__SLATE_DECORATION__@@',\n  document: '@@__SLATE_DOCUMENT__@@',\n  editor: '@@__SLATE_EDITOR__@@',\n  inline: '@@__SLATE_INLINE__@@',\n  leaf: '@@__SLATE_LEAF__@@',\n  mark: '@@__SLATE_MARK__@@',\n  operation: '@@__SLATE_OPERATION__@@',\n  point: '@@__SLATE_POINT__@@',\n  range: '@@__SLATE_RANGE__@@',\n  selection: '@@__SLATE_SELECTION__@@',\n  text: '@@__SLATE_TEXT__@@',\n  value: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Determine whether a `value` is of `type`.\n *\n * @param {string} type\n * @param {any} value\n * @return {boolean}\n */\n\nexport default function isObject(type, value) {\n  return !!(value && value[TYPES[type]])\n}\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Decoration from './decoration'\nimport Point from './point'\nimport Selection from './selection'\nimport isObject from '../utils/is-object'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      if (attrs.object === 'range') {\n        return attrs\n      } else {\n        return Range.fromJSON(Range.createProperties(attrs))\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects, decorations, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus } = object\n    const range = new Range({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return range\n  }\n\n  /**\n   * Check if a `value` is a `Range`, or is range-like.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isRange(value) {\n    return (\n      isObject('range', value) ||\n      Decoration.isDecoration(value) ||\n      Selection.isSelection(value)\n    )\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport { Record, Set } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n  isFocused: undefined,\n  marks: undefined,\n}\n\n/**\n * Selection.\n *\n * @type {Selection}\n */\n\nclass Selection extends Record(DEFAULTS) {\n  /**\n   * Create a new `Selection` with `attrs`.\n   *\n   * @param {Object|Selection} attrs\n   * @return {Selection}\n   */\n\n  static create(attrs = {}) {\n    if (Selection.isSelection(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Selection.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Selection.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Selection.create\\` only accepts objects, ranges or selections, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable selection properties from `attrs`.\n   *\n   * @param {Object|String|Selection} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Selection.isSelection(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        isFocused: a.isFocused,\n        marks: a.marks,\n      }\n    }\n\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('isFocused' in a) p.isFocused = a.isFocused\n      if ('marks' in a)\n        p.marks = a.marks == null ? null : Mark.createSet(a.marks)\n      return p\n    }\n\n    throw new Error(\n      `\\`Selection.createProperties\\` only accepts objects, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Selection` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Selection}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, isFocused = false, marks = null } = object\n    const selection = new Selection({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return selection\n  }\n\n  /**\n   * Check whether the selection is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Set the `isFocused` property to a new `value`.\n   *\n   * @param {Boolean} value\n   * @return {Selection}\n   */\n\n  setIsFocused(value) {\n    const selection = this.set('isFocused', value)\n    return selection\n  }\n\n  /**\n   * Set the `marks` property to a new set of `marks`.\n   *\n   * @param {Set} marks\n   * @return {Selection}\n   */\n\n  setMarks(marks) {\n    const selection = this.set('marks', marks)\n    return selection\n  }\n\n  /**\n   * Set new `properties` on the selection.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Selection.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const selection = this.merge(props)\n    return selection\n  }\n\n  /**\n   * Return a JSON representation of the selection.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Selection}\n */\n\nexport default Selection\n","import isPlainObject from 'is-plain-object'\nimport invariant from 'tiny-invariant'\nimport { Record, Set, List } from 'immutable'\n\nimport PathUtils from '../utils/path-utils'\nimport Data from './data'\nimport Decoration from './decoration'\nimport Document from './document'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  decorations: undefined,\n  document: undefined,\n  selection: undefined,\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Value.isValue(a)) {\n      return {\n        data: a.data,\n        decorations: a.decorations,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('decorations' in a)\n        p.decorations = Decoration.createList(a.decorations)\n      return p\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let { data = {}, decorations = [], document = {}, selection = {} } = object\n    data = Data.fromJSON(data)\n    document = Document.fromJSON(document)\n    selection = document.createSelection(selection)\n    decorations = List(decorations.map(d => Decoration.fromJSON(d)))\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.moveToStartOfNode(text)\n      selection = document.createSelection(selection)\n    }\n\n    const value = new Value({\n      data,\n      decorations,\n      document,\n      selection,\n    })\n\n    return value\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestBlock(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestBlock(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestInline(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestInline(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return (\n      this.selection.start.key &&\n      this.document.getDescendant(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return (\n      this.selection.end.key &&\n      this.document.getDescendant(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getDescendant(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return (\n      this.selection.focus.key &&\n      this.document.getDescendant(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextText(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousText(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addMark(path, offset, length, mark) {\n    let value = this\n    let { document } = value\n    document = document.addMark(path, offset, length, mark)\n    value = this.set('document', document)\n    return value\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Value}\n   */\n\n  insertNode(path, node) {\n    let value = this\n    let { document } = value\n    document = document.insertNode(path, node)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range =>\n      range.updatePoints(point => point.setPath(null))\n    )\n\n    return value\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @param {Set} marks\n   * @return {Value}\n   */\n\n  insertText(path, offset, text, marks) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    document = document.insertText(path, offset, text, marks)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      return range.updatePoints(point => {\n        return point.key === node.key && point.offset >= offset\n          ? point.setOffset(point.offset + text.length)\n          : point\n      })\n    })\n\n    return value\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Value}\n   */\n\n  mergeNode(path) {\n    let value = this\n    const { document } = value\n    const newDocument = document.mergeNode(path)\n    path = document.resolvePath(path)\n    const withPath = PathUtils.decrement(path)\n    const one = document.getNode(withPath)\n    const two = document.getNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      if (two.object === 'text') {\n        const max = one.text.length\n\n        if (range.anchor.key === two.key) {\n          range = range.moveAnchorTo(one.key, max + range.anchor.offset)\n        }\n\n        if (range.focus.key === two.key) {\n          range = range.moveFocusTo(one.key, max + range.focus.offset)\n        }\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Value}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    let value = this\n    let { document } = value\n    document = document.moveNode(path, newPath, newIndex)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range =>\n      range.updatePoints(point => point.setPath(null))\n    )\n\n    return value\n  }\n\n  /**\n   * Remove mark from text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeMark(path, offset, length, mark) {\n    let value = this\n    let { document } = value\n    document = document.removeMark(path, offset, length, mark)\n    value = this.set('document', document)\n    return value\n  }\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Value}\n   */\n\n  removeNode(path) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    const first = node.object == 'text' ? node : node.getFirstText() || node\n    const last = node.object == 'text' ? node : node.getLastText() || node\n    const prev = document.getPreviousText(first.key)\n    const next = document.getNextText(last.key)\n\n    document = document.removeNode(path)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      const { start, end } = range\n\n      if (node.hasNode(start.key)) {\n        range = prev\n          ? range.moveStartTo(prev.key, prev.text.length)\n          : next ? range.moveStartTo(next.key, 0) : range.unset()\n      }\n\n      if (node.hasNode(end.key)) {\n        range = prev\n          ? range.moveEndTo(prev.key, prev.text.length)\n          : next ? range.moveEndTo(next.key, 0) : range.unset()\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  removeText(path, offset, text) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    document = document.removeText(path, offset, text)\n    value = value.set('document', document)\n\n    const { length } = text\n    const start = offset\n    const end = offset + length\n\n    value = value.mapRanges(range => {\n      return range.updatePoints(point => {\n        if (point.key !== node.key) {\n          return point\n        }\n\n        if (point.offset >= end) {\n          return point.setOffset(point.offset - length)\n        }\n\n        if (point.offset > start) {\n          return point.setOffset(start)\n        }\n\n        return point\n      })\n    })\n\n    return value\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setNode(path, properties) {\n    let value = this\n    let { document } = value\n    document = document.setNode(path, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setMark(path, offset, length, mark, properties) {\n    let value = this\n    let { document } = value\n    document = document.setMark(path, offset, length, mark, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on the value.\n   *\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setProperties(properties) {\n    let value = this\n    const { document } = value\n    const { data, decorations } = properties\n    const props = {}\n\n    if (data) {\n      props.data = data\n    }\n\n    if (decorations) {\n      props.decorations = decorations.map(d => {\n        return d.isSet ? d : document.resolveDecoration(d)\n      })\n    }\n\n    value = value.merge(props)\n    return value\n  }\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  setSelection(properties) {\n    let value = this\n    let { document, selection } = value\n    const next = selection.setProperties(properties)\n    selection = document.resolveSelection(next)\n    value = value.set('selection', selection)\n    return value\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  splitNode(path, position, properties) {\n    let value = this\n    const { document } = value\n    const newDocument = document.splitNode(path, position, properties)\n    const node = document.assertNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      const next = newDocument.getNextText(node.key)\n      const { start, end } = range\n\n      // If the start was after the split, move it to the next node.\n      if (node.key === start.key && position <= start.offset) {\n        range = range.moveStartTo(next.key, start.offset - position)\n      }\n\n      // If the end was after the split, move it to the next node.\n      if (node.key === end.key && position <= end.offset) {\n        range = range.moveEndTo(next.key, end.offset - position)\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Map all range objects to apply adjustments with an `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Value}\n   */\n\n  mapRanges(iterator) {\n    let value = this\n    const { document, selection, decorations } = value\n\n    let sel = selection.isSet ? iterator(selection) : selection\n    if (!sel) sel = selection.unset()\n    if (sel !== selection) sel = document.createSelection(sel)\n    value = value.set('selection', sel)\n\n    let decs = decorations.map(decoration => {\n      let n = decoration.isSet ? iterator(decoration) : decoration\n      if (n && n !== decoration) n = document.createDecoration(n)\n      return n\n    })\n\n    decs = decs.filter(decoration => !!decoration)\n    value = value.set('decorations', decs)\n    return value\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON(options)\n    }\n\n    if (options.preserveDecorations) {\n      object.decorations = this.decorations\n        .toArray()\n        .map(d => d.toJSON(options))\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON(options)\n    }\n\n    return object\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get history() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.'\n    )\n  }\n\n  change() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.'\n    )\n  }\n}\n\n/**\n * Export.\n */\n\nexport default Value\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'add_mark': {\n      const { path, offset, length, mark } = op\n      const next = value.addMark(path, offset, length, mark)\n      return next\n    }\n\n    case 'insert_node': {\n      const { path, node } = op\n      const next = value.insertNode(path, node)\n      return next\n    }\n\n    case 'insert_text': {\n      const { path, offset, text, marks } = op\n      const next = value.insertText(path, offset, text, marks)\n      return next\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const next = value.mergeNode(path)\n      return next\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (PathUtils.isEqual(path, newPath)) {\n        return value\n      }\n\n      const next = value.moveNode(path, newPath)\n      return next\n    }\n\n    case 'remove_mark': {\n      const { path, offset, length, mark } = op\n      const next = value.removeMark(path, offset, length, mark)\n      return next\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const next = value.removeNode(path)\n      return next\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      const next = value.removeText(path, offset, text)\n      return next\n    }\n\n    case 'set_mark': {\n      const { path, offset, length, mark, properties } = op\n      const next = value.setMark(path, offset, length, mark, properties)\n      return next\n    }\n\n    case 'set_node': {\n      const { path, properties } = op\n      const next = value.setNode(path, properties)\n      return next\n    }\n\n    case 'set_selection': {\n      const { properties } = op\n      const next = value.setSelection(properties)\n      return next\n    }\n\n    case 'set_value': {\n      const { properties } = op\n      const next = value.setProperties(properties)\n      return next\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n      const next = value.splitNode(path, position, properties)\n      return next\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\nimport pick from 'lodash/pick'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'insert_node': {\n      const inverse = op.set('type', 'remove_node')\n      return inverse\n    }\n\n    case 'remove_node': {\n      const inverse = op.set('type', 'insert_node')\n      return inverse\n    }\n\n    case 'move_node': {\n      const { newPath, path } = op\n\n      if (PathUtils.isEqual(newPath, path)) {\n        return op\n      }\n\n      let inversePath = newPath\n      let inverseNewPath = path\n\n      const pathLast = path.size - 1\n      const newPathLast = newPath.size - 1\n\n      // If the node's old position was a left sibling of an ancestor of\n      // its new position, we need to adjust part of the path by -1.\n      if (\n        path.size < inversePath.size &&\n        path.slice(0, pathLast).every((e, i) => e == inversePath.get(i)) &&\n        path.last() < inversePath.get(pathLast)\n      ) {\n        inversePath = inversePath\n          .slice(0, pathLast)\n          .concat(inversePath.get(pathLast) - 1)\n          .concat(inversePath.slice(pathLast + 1, inversePath.size))\n      }\n\n      // If the node's new position is an ancestor of the old position,\n      // or a left sibling of an ancestor of its old position, we need\n      // to adjust part of the path by 1.\n      if (\n        newPath.size < inverseNewPath.size &&\n        newPath\n          .slice(0, newPathLast)\n          .every((e, i) => e == inverseNewPath.get(i)) &&\n        newPath.last() <= inverseNewPath.get(newPathLast)\n      ) {\n        inverseNewPath = inverseNewPath\n          .slice(0, newPathLast)\n          .concat(inverseNewPath.get(newPathLast) + 1)\n          .concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.size))\n      }\n\n      const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n      return inverse\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const inversePath = PathUtils.decrement(path)\n      const inverse = op.set('type', 'split_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const inversePath = PathUtils.increment(path)\n      const inverse = op.set('type', 'merge_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'set_node': {\n      const { properties, node } = op\n      const inverseNode = node.merge(properties)\n      const inverseProperties = pick(node, Object.keys(properties))\n      const inverse = op\n        .set('node', inverseNode)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    case 'insert_text': {\n      const inverse = op.set('type', 'remove_text')\n      return inverse\n    }\n\n    case 'remove_text': {\n      const inverse = op.set('type', 'insert_text')\n      return inverse\n    }\n\n    case 'add_mark': {\n      const inverse = op.set('type', 'remove_mark')\n      return inverse\n    }\n\n    case 'remove_mark': {\n      const inverse = op.set('type', 'add_mark')\n      return inverse\n    }\n\n    case 'set_mark': {\n      const { properties, mark } = op\n      const inverseMark = mark.merge(properties)\n      const inverseProperties = pick(mark, Object.keys(properties))\n      const inverse = op\n        .set('mark', inverseMark)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    case 'set_selection': {\n      const { properties, selection } = op\n      const inverseSelection = selection.merge(properties)\n      const inverseProps = pick(selection, Object.keys(properties))\n      const inverse = op\n        .set('selection', inverseSelection)\n        .set('properties', inverseProps)\n      return inverse\n    }\n\n    case 'set_value': {\n      const { properties, value } = op\n      const inverseValue = value.merge(properties)\n      const inverseProperties = pick(value, Object.keys(properties))\n      const inverse = op\n        .set('value', inverseValue)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport Node from './node'\nimport PathUtils from '../utils/path-utils'\nimport Selection from './selection'\nimport Value from './value'\nimport apply from '../operations/apply'\nimport invert from '../operations/invert'\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target'],\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      if (v === undefined) {\n        // Skip keys for objects that should not be serialized, and are only used\n        // for providing the local-only invert behavior for the history stack.\n        if (key == 'document') continue\n        if (key == 'selection') continue\n        if (key == 'value') continue\n        if (key == 'node' && type != 'insert_node') continue\n\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key === 'path' || key === 'newPath') {\n        v = PathUtils.create(v)\n      }\n\n      if (key === 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key === 'marks' && v != null) {\n        v = Mark.createSet(v)\n      }\n\n      if (key === 'node') {\n        v = Node.create(v)\n      }\n\n      if (key === 'selection') {\n        v = Selection.create(v)\n      }\n\n      if (key === 'value') {\n        v = Value.create(v)\n      }\n\n      if (key === 'properties' && type === 'merge_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_mark') {\n        v = Mark.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_selection') {\n        v = Selection.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_value') {\n        v = Value.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'split_node') {\n        v = Node.createProperties(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const node = new Operation(attrs)\n    return node\n  }\n\n  /**\n   * Check if `any` is a listÂ of operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Apply the operation to a `value`.\n   *\n   * @param {Value} value\n   * @return {Value}\n   */\n\n  apply(value) {\n    const next = apply(value, this)\n    return next\n  }\n\n  /**\n   * Invert the operation.\n   *\n   * @return {Operation}\n   */\n\n  invert() {\n    const inverted = invert(this)\n    return inverted\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      // Skip keys for objects that should not be serialized, and are only used\n      // for providing the local-only invert behavior for the history stack.\n      if (key == 'document') continue\n      if (key == 'selection') continue\n      if (key == 'value') continue\n      if (key == 'node' && type != 'insert_node') continue\n\n      if (\n        key == 'mark' ||\n        key == 'marks' ||\n        key == 'node' ||\n        key == 'path' ||\n        key == 'newPath'\n      ) {\n        value = value.toJSON()\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const v = {}\n        if ('anchor' in value) v.anchor = value.anchor.toJSON()\n        if ('focus' in value) v.focus = value.focus.toJSON()\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value) v.marks = value.marks && value.marks.toJSON()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('decorations' in value) v.decorations = value.decorations.toJS()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n}\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:change')\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change {\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  constructor(attrs) {\n    const { editor, value } = attrs\n    this.editor = editor\n    this.value = value\n    this.operations = new List()\n\n    this.tmp = {\n      dirty: [],\n      merge: null,\n      normalize: true,\n      save: true,\n    }\n  }\n\n  /**\n   * Apply an `operation` to the current value, saving the operation to the\n   * history if needed.\n   *\n   * @param {Operation|Object} operation\n   * @return {Change}\n   */\n\n  applyOperation(operation) {\n    const { operations } = this\n    let value = this.value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Save the operation into the history. Since `save` is a command, we need\n    // to do it without normalizing, since it would have side effects.\n    this.withoutNormalizing(() => {\n      this.save(operation)\n      value = this.value\n    })\n\n    // Apply the operation to the value.\n    debug('apply', { operation })\n    value = operation.apply(value)\n\n    // Get the paths of the affected nodes, and mark them as dirty.\n    const newDirtyPaths = getDirtyPaths(operation)\n    const dirty = this.tmp.dirty.reduce((memo, path) => {\n      path = PathUtils.create(path)\n      const transformed = PathUtils.transform(path, operation)\n      memo = memo.concat(transformed.toArray())\n      return memo\n    }, newDirtyPaths)\n\n    this.tmp.dirty = dirty\n\n    // Update the mutable change object.\n    this.value = value\n    this.operations = operations.push(operation)\n    return this\n  }\n\n  /**\n   * Apply a series of `operations` to the current value.\n   *\n   * @param {Array|List} operations\n   * @return {Change}\n   */\n\n  applyOperations(operations) {\n    operations.forEach(op => this.applyOperation(op))\n    return this\n  }\n\n  /**\n   * Call a change `fn` with arguments.\n   *\n   * @param {Function} fn\n   * @param {Mixed} ...args\n   * @return {Change}\n   */\n\n  call(fn, ...args) {\n    fn(this, ...args)\n    this.normalizeDirtyPaths()\n    return this\n  }\n\n  /**\n   * Run a `command` with `args`.\n   *\n   * @param {String} command\n   * @param {Any} ...args\n   * @return {Change}\n   */\n\n  command(command, ...args) {\n    const { editor } = this\n    editor.command(command, ...args)\n    return this\n  }\n\n  /**\n   * Run a `query` with `args`.\n   *\n   * @param {String} query\n   * @param {Any} ...args\n   * @return {Change}\n   */\n\n  query(query, ...args) {\n    const { editor } = this\n    return editor.query(query, ...args)\n  }\n\n  /**\n   * Normalize all of the nodes in the document from scratch.\n   *\n   * @return {Change}\n   */\n\n  normalize() {\n    const { value } = this\n    let { document } = value\n    const table = document.getKeysToPathsTable()\n    const paths = Object.values(table).map(PathUtils.create)\n    this.tmp.dirty = this.tmp.dirty.concat(paths)\n    this.normalizeDirtyPaths()\n\n    const { selection } = value\n    document = value.document\n\n    if (selection.isUnset && document.nodes.size) {\n      this.moveToStartOfDocument()\n    }\n\n    return this\n  }\n\n  /**\n   * Normalize any new \"dirty\" paths that have been added to the change.\n   *\n   * @return {Change}\n   */\n\n  normalizeDirtyPaths() {\n    if (!this.tmp.normalize) {\n      return this\n    }\n\n    while (this.tmp.dirty.length) {\n      const path = this.tmp.dirty.pop()\n      this.normalizeNodeByPath(path)\n    }\n\n    return this\n  }\n\n  /**\n   * Normalize the node at a specific `path`.\n   *\n   * @param {Array} path\n   * @return {Change}\n   */\n\n  normalizeNodeByPath(path) {\n    const { editor, value } = this\n    let { document } = value\n    let node = document.assertNode(path)\n    let iterations = 0\n    const max = 1000 + (node.object === 'text' ? 1 : node.nodes.size)\n\n    const iterate = () => {\n      const fn = node.normalize(editor)\n      if (!fn) return\n\n      // Run the normalize `fn` to fix the node.\n      fn(this)\n\n      // Attempt to re-find the node by path, or by key if it has changed\n      // locations in the tree continue iterating.\n      document = this.value.document\n      const { key } = node\n      let found = document.getDescendant(path)\n\n      if (found && found.key === key) {\n        node = found\n      } else {\n        found = document.getDescendant(key)\n\n        if (found) {\n          node = found\n          path = document.getPath(key)\n        } else {\n          // If it no longer exists by key, it was removed, so abort.\n          return\n        }\n      }\n\n      // Increment the iterations counter, and check to make sure that we haven't\n      // exceeded the max. Without this check, it's easy for the `normalize`\n      // function of a schema rule to be written incorrectly and for an infinite\n      // invalid loop to occur.\n      iterations++\n\n      if (iterations > max) {\n        throw new Error(\n          'A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.'\n        )\n      }\n\n      // Otherwise, iterate again.\n      iterate()\n    }\n\n    this.withoutNormalizing(() => {\n      iterate()\n    })\n\n    return this\n  }\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, deferring\n   * normalization until after the function has finished executing.\n   *\n   * @param {Function} fn\n   * @return {Change}\n   */\n\n  withoutNormalizing(fn) {\n    const value = this.tmp.normalize\n    this.tmp.normalize = false\n    fn(this)\n    this.tmp.normalize = value\n    this.normalizeDirtyPaths()\n    return this\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  setOperationFlag(key, value) {\n    warning(\n      false,\n      'As of slate@0.41.0 the `change.setOperationFlag` method has been deprecated.'\n    )\n\n    this.tmp[key] = value\n    return this\n  }\n\n  getFlag(key, options = {}) {\n    warning(\n      false,\n      'As of slate@0.41.0 the `change.getFlag` method has been deprecated.'\n    )\n\n    return options[key] !== undefined ? options[key] : this.tmp[key]\n  }\n\n  unsetOperationFlag(key) {\n    warning(\n      false,\n      'As of slate@0.41.0 the `change.unsetOperationFlag` method has been deprecated.'\n    )\n\n    delete this.tmp[key]\n    return this\n  }\n\n  withoutNormalization(fn) {\n    warning(\n      false,\n      'As of slate@0.41.0 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.'\n    )\n\n    return this.withoutNormalizing(fn)\n  }\n}\n\n/**\n * Get the \"dirty\" paths for a given `operation`.\n *\n * @param {Operation} operation\n * @return {Array}\n */\n\nfunction getDirtyPaths(operation) {\n  const { type, node, path, newPath } = operation\n\n  switch (type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path]\n    }\n\n    case 'insert_node': {\n      const table = node.getKeysToPathsTable()\n      const paths = Object.values(table).map(p => path.concat(p))\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path, ...paths]\n    }\n\n    case 'split_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const nextPath = PathUtils.increment(path)\n      return [...ancestors, path, nextPath]\n    }\n\n    case 'merge_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const previousPath = PathUtils.decrement(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      let parentPath = PathUtils.lift(path)\n      let newParentPath = PathUtils.lift(newPath)\n\n      if (PathUtils.isEqual(path, newPath)) {\n        return []\n      }\n\n      // HACK: this clause only exists because the `move_path` logic isn't\n      // consistent when it deals with siblings.\n      if (!PathUtils.isSibling(path, newPath)) {\n        if (newParentPath.size && PathUtils.isYounger(path, newPath)) {\n          newParentPath = PathUtils.decrement(newParentPath, 1, path.size - 1)\n        }\n\n        if (parentPath.size && PathUtils.isYounger(newPath, path)) {\n          parentPath = PathUtils.increment(parentPath, 1, newPath.size - 1)\n        }\n      }\n\n      const oldAncestors = PathUtils.getAncestors(parentPath).toArray()\n      const newAncestors = PathUtils.getAncestors(newParentPath).toArray()\n\n      return [...oldAncestors, parentPath, ...newAncestors, newParentPath]\n    }\n\n    case 'remove_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nconst PROXY_TRANSFORMS = [\n  'deleteBackward',\n  'deleteCharBackward',\n  'deleteLineBackward',\n  'deleteWordBackward',\n  'deleteForward',\n  'deleteCharForward',\n  'deleteWordForward',\n  'deleteLineForward',\n  'setBlocks',\n  'setInlines',\n  'splitInline',\n  'unwrapBlock',\n  'unwrapInline',\n  'wrapBlock',\n  'wrapInline',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Commands[method] = (change, ...args) => {\n    const { value } = change\n    const { selection } = value\n    const methodAtRange = `${method}AtRange`\n    change[methodAtRange](selection, ...args)\n\n    if (method.match(/Backward$/)) {\n      change.moveToStart()\n    } else if (method.match(/Forward$/)) {\n      change.moveToEnd()\n    }\n  }\n})\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nCommands.addMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nCommands.addMarks = (change, marks) => {\n  marks.forEach(mark => change.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nCommands.delete = change => {\n  const { value } = change\n  const { selection } = value\n  change.deleteAtRange(selection)\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.moveToStart()\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nCommands.insertBlock = (change, block) => {\n  block = Block.create(block)\n  const { value } = change\n  const { selection } = value\n  change.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(block.key)\n  if (node) change.moveToEndOfNode(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nCommands.insertFragment = (change, fragment) => {\n  if (!fragment.nodes.size) return\n\n  let { value } = change\n  let { document, selection } = value\n  const { start, end } = selection\n  const { startText, endText, startInline } = value\n  const lastText = fragment.getLastText()\n  const lastInline = fragment.getClosestInline(lastText.key)\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const keys = document.getTexts().map(text => text.key)\n  const isAppending =\n    !startInline ||\n    (start.isAtStartOfNode(startText) || end.isAtStartOfNode(startText)) ||\n    (start.isAtEndOfNode(endText) || end.isAtEndOfNode(endText))\n\n  const isInserting =\n    firstChild.hasBlockChildren() || lastChild.hasBlockChildren()\n\n  change.insertFragmentAtRange(selection, fragment)\n  value = change.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  const newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first()\n\n  if (newText && (lastInline || isInserting)) {\n    change.select(selection.moveToEndOfNode(newText))\n  } else if (newText) {\n    change.select(\n      selection.moveToStartOfNode(newText).moveForward(lastText.text.length)\n    )\n  } else {\n    change.select(selection.moveToStart().moveForward(lastText.text.length))\n  }\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nCommands.insertInline = (change, inline) => {\n  inline = Inline.create(inline)\n  const { value } = change\n  const { selection } = value\n  change.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(inline.key)\n  if (node) change.moveToEndOfNode(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertText = (change, text, marks) => {\n  const { value } = change\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n  change.insertTextAtRange(selection, text, marks)\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null })\n  }\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nCommands.removeMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nCommands.replaceMark = (change, oldMark, newMark) => {\n  change.removeMark(oldMark)\n  change.addMark(newMark)\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nCommands.splitBlock = (change, depth = 1) => {\n  const { value } = change\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  change.splitBlockAtRange(selection, depth).moveToEnd()\n\n  if (marks && marks.size !== 0) {\n    change.select({ marks })\n  }\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nCommands.toggleMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    change.removeMark(mark)\n  } else {\n    change.addMark(mark)\n  }\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nCommands.wrapText = (change, prefix, suffix = prefix) => {\n  const { value } = change\n  const { selection } = value\n  change.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStartBackward(prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEndBackward(suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  const char = text.charAt(0)\n  return getCharLength(char)\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharLength,\n  getCharOffset,\n  getCharOffsetBackward,\n  getCharOffsetForward,\n  getWordOffset,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n  isSurrogate,\n  isWord,\n}\n","import { List } from 'immutable'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport TextUtils from '../utils/text-utils'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.addMarkAtRange = (change, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = change\n  const { document } = value\n  const { start, end } = range\n  const texts = document.getTextsAtRange(range)\n\n  change.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key == start.key) index = start.offset\n      if (key == end.key) length = end.offset\n      if (key == start.key && key == end.key) length = end.offset - start.offset\n\n      change.addMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n */\n\nCommands.addMarksAtRange = (change, range, marks) => {\n  marks.forEach(mark => change.addMarkAtRange(range, mark))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n */\n\nCommands.deleteAtRange = (change, range) => {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection()\n\n  const { editor, value } = change\n  const { start, end } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  let endKey = end.key\n  let endOffset = end.offset\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey, editor)\n  let isEndVoid = document.hasVoidParent(endKey, editor)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey, editor)\n  }\n\n  change.withoutNormalizing(() => {\n    // If the start node is inside a void node, remove the void node and update\n    // the starting point to be right after it, continuously until the start point\n    // is not a void, or until the entire range is handled.\n    while (isStartVoid) {\n      const startVoid = document.getClosestVoid(startKey, editor)\n      const nextText = document.getNextText(startKey)\n      change.removeNodeByKey(startVoid.key)\n\n      // If the start and end keys are the same, we're done.\n      if (startKey == endKey) return\n\n      // If there is no next text node, we're done.\n      if (!nextText) return\n\n      // Continue...\n      document = change.value.document\n      startKey = nextText.key\n      startOffset = 0\n      isStartVoid = document.hasVoidParent(startKey, editor)\n    }\n\n    // If the end node is inside a void node, do the same thing but backwards. But\n    // we don't need any aborting checks because if we've gotten this far there\n    // must be a non-void node that will exit the loop.\n    while (isEndVoid) {\n      const endVoid = document.getClosestVoid(endKey, editor)\n      const prevText = document.getPreviousText(endKey)\n      change.removeNodeByKey(endVoid.key)\n\n      // Continue...\n      document = change.value.document\n      endKey = prevText.key\n      endOffset = prevText.text.length\n      isEndVoid = document.hasVoidParent(endKey, editor)\n    }\n\n    // If the start and end key are the same, and it was a hanging selection, we\n    // can just remove the entire block.\n    if (startKey == endKey && isHanging) {\n      change.removeNodeByKey(startBlock.key)\n      return\n    } else if (startKey == endKey) {\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n      // simply remove the text in the range.\n      const index = startOffset\n      const length = endOffset - startOffset\n      change.removeTextByKey(startKey, index, length)\n      return\n    } else {\n      // Otherwise, we need to recursively remove text and nodes inside the start\n      // block after the start offset and inside the end block before the end\n      // offset. Then remove any blocks that are in between the start and end\n      // blocks. Then finally merge the start and end nodes.\n      startBlock = document.getClosestBlock(startKey)\n      endBlock = document.getClosestBlock(endKey)\n      const startText = document.getNode(startKey)\n      const endText = document.getNode(endKey)\n      const startLength = startText.text.length - startOffset\n      const endLength = endOffset\n\n      const ancestor = document.getCommonAncestor(startKey, endKey)\n      const startChild = ancestor.getFurthestAncestor(startKey)\n      const endChild = ancestor.getFurthestAncestor(endKey)\n\n      const startParent = document.getParent(startBlock.key)\n      const startParentIndex = startParent.nodes.indexOf(startBlock)\n      const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n      let child\n\n      // Iterate through all of the nodes in the tree after the start text node\n      // but inside the end child, and remove them.\n      child = startText\n\n      while (child.key != startChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const afters = parent.nodes.slice(index + 1)\n\n        afters.reverse().forEach(node => {\n          change.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove all of the middle children.\n      const startChildIndex = ancestor.nodes.indexOf(startChild)\n      const endChildIndex = ancestor.nodes.indexOf(endChild)\n      const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n      middles.reverse().forEach(node => {\n        change.removeNodeByKey(node.key)\n      })\n\n      // Remove the nodes before the end text node in the tree.\n      child = endText\n\n      while (child.key != endChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const befores = parent.nodes.slice(0, index)\n\n        befores.reverse().forEach(node => {\n          change.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove any overlapping text content from the leaf text nodes.\n      if (startLength != 0) {\n        change.removeTextByKey(startKey, startOffset, startLength)\n      }\n\n      if (endLength != 0) {\n        change.removeTextByKey(endKey, 0, endOffset)\n      }\n\n      // If the start and end blocks aren't the same, move and merge the end block\n      // into the start block.\n      if (startBlock.key != endBlock.key) {\n        document = change.value.document\n        const lonely = document.getFurthestOnlyChildAncestor(endBlock.key)\n\n        // Move the end block to be right after the start block.\n        if (endParentIndex != startParentIndex + 1) {\n          change.moveNodeByKey(\n            endBlock.key,\n            startParent.key,\n            startParentIndex + 1\n          )\n        }\n\n        // If the selection is hanging, just remove the start block, otherwise\n        // merge the end block into it.\n        if (isHanging) {\n          change.removeNodeByKey(startBlock.key)\n        } else {\n          change.mergeNodeByKey(endBlock.key)\n        }\n\n        // If nested empty blocks are left over above the end block, remove them.\n        if (lonely) {\n          change.removeNodeByKey(lonely.key)\n        }\n      }\n    }\n  })\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n */\n\nCommands.deleteCharBackwardAtRange = (change, range) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n */\n\nCommands.deleteLineBackwardAtRange = (change, range) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  change.deleteBackwardAtRange(range, o)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n */\n\nCommands.deleteWordBackwardAtRange = (change, range) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteBackwardAtRange = (change, range, n = 1) => {\n  if (n === 0) return\n  const { editor, value } = change\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.key, editor)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  const block = document.getClosestBlock(start.key)\n\n  // If the closest is not void, but empty, remove it\n  if (\n    block &&\n    !change.isVoid(block) &&\n    block.text === '' &&\n    document.nodes.size !== 1\n  ) {\n    change.removeNodeByKey(block.key)\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtStartOfNode(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.key)\n\n  if (start.isAtStartOfNode(text)) {\n    const prev = document.getPreviousText(text.key)\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key, editor)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      change.removeNodeByKey(prevVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length)\n      change.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focus.offset) {\n    range = range.moveFocusBackward(n)\n    change.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focus.offset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset)\n  change.deleteAtRange(range)\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n */\n\nCommands.deleteCharForwardAtRange = (change, range) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n */\n\nCommands.deleteLineForwardAtRange = (change, range) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  change.deleteForwardAtRange(range, startBlock.text.length - o)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n */\n\nCommands.deleteWordForwardAtRange = (change, range) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const wordOffset = TextUtils.getWordOffsetForward(text, o)\n  const n = wordOffset === 0 ? 1 : wordOffset\n  change.deleteForwardAtRange(range, n)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteForwardAtRange = (change, range, n = 1) => {\n  if (n === 0) return\n  const { editor, value } = change\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.key, editor)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  const block = document.getClosestBlock(start.key)\n\n  // If the closest is not void, but empty, remove it\n  if (\n    block &&\n    !change.isVoid(block) &&\n    block.text === '' &&\n    document.nodes.size !== 1\n  ) {\n    const nextBlock = document.getNextBlock(block.key)\n    change.removeNodeByKey(block.key)\n\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOfNode(nextBlock)\n    }\n\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtEndOfNode(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.key)\n\n  if (start.isAtEndOfNode(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key, editor)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      change.removeNodeByKey(nextVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.moveFocusTo(next.key, 0)\n      change.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n)\n    change.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focus.offset\n  let traversed = text.text.length - focus.offset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset)\n  change.deleteAtRange(range)\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n */\n\nCommands.insertBlockAtRange = (change, range, block) => {\n  block = Block.create(block)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    range = range.moveToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n\n  if (change.isVoid(startBlock)) {\n    const extra = start.isAtEndOfNode(startBlock) ? 1 : 0\n    change.insertNodeByKey(parent.key, index + extra, block)\n  } else if (!startInline && startBlock.text === '') {\n    change.insertNodeByKey(parent.key, index + 1, block)\n  } else if (start.isAtStartOfNode(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block)\n  } else if (start.isAtEndOfNode(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block)\n  } else {\n    if (startInline && change.isVoid(startInline)) {\n      const atEnd = start.isAtEndOfNode(startInline)\n      const siblingText = atEnd\n        ? document.getNextText(startKey)\n        : document.getPreviousText(startKey)\n\n      const splitRange = atEnd\n        ? range.moveToStartOfNode(siblingText)\n        : range.moveToEndOfNode(siblingText)\n\n      startKey = splitRange.start.key\n      startOffset = splitRange.start.offset\n    }\n\n    change.withoutNormalizing(() => {\n      change.splitDescendantsByKey(startBlock.key, startKey, startOffset)\n      change.insertNodeByKey(parent.key, index + 1, block)\n    })\n  }\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n */\n\nCommands.insertFragmentAtRange = (change, range, fragment) => {\n  change.withoutNormalizing(() => {\n    // If the range is expanded, delete it first.\n    if (range.isExpanded) {\n      change.deleteAtRange(range)\n\n      if (change.value.document.getDescendant(range.start.key)) {\n        range = range.moveToStart()\n      } else {\n        range = range.moveTo(range.end.key, 0).normalize(change.value.document)\n      }\n    }\n\n    // If the fragment is empty, there's nothing to do after deleting.\n    if (!fragment.nodes.size) return\n\n    // Regenerate the keys for all of the fragments nodes, so that they're\n    // guaranteed not to collide with the existing keys in the document. Otherwise\n    // they will be rengerated automatically and we won't have an easy way to\n    // reference them.\n    fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n    // Calculate a few things...\n    const { start } = range\n    const { value } = change\n    let { document } = value\n    let startText = document.getDescendant(start.key)\n    let startBlock = document.getClosestBlock(startText.key)\n    let startChild = startBlock.getFurthestAncestor(startText.key)\n    const isAtStart = start.isAtStartOfNode(startBlock)\n    const parent = document.getParent(startBlock.key)\n    const index = parent.nodes.indexOf(startBlock)\n    const blocks = fragment.getBlocks()\n    const firstChild = fragment.nodes.first()\n    const lastChild = fragment.nodes.last()\n    const firstBlock = blocks.first()\n    const lastBlock = blocks.last()\n    const insertionNode = findInsertionNode(fragment, document, startBlock.key)\n\n    // If the fragment only contains a void block, use `insertBlock` instead.\n    if (firstBlock === lastBlock && change.isVoid(firstBlock)) {\n      change.insertBlockAtRange(range, firstBlock)\n      return\n    }\n\n    // If inserting the entire fragment and it starts or ends with a single\n    // nested block, e.g. a table, we do not merge it with existing blocks.\n    if (\n      insertionNode === fragment &&\n      (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())\n    ) {\n      fragment.nodes.reverse().forEach(node => {\n        change.insertBlockAtRange(range, node)\n      })\n      return\n    }\n\n    // If the first and last block aren't the same, we need to insert all of the\n    // nodes after the insertion node's first block at the index.\n    if (firstBlock != lastBlock) {\n      const lonelyParent = insertionNode.getFurthest(\n        firstBlock.key,\n        p => p.nodes.size == 1\n      )\n      const lonelyChild = lonelyParent || firstBlock\n\n      const startIndex = parent.nodes.indexOf(startBlock)\n      const excludingLonelyChild = insertionNode.removeNode(lonelyChild.key)\n\n      excludingLonelyChild.nodes.forEach((node, i) => {\n        const newIndex = startIndex + i + 1\n        change.insertNodeByKey(parent.key, newIndex, node)\n      })\n    }\n\n    // Check if we need to split the node.\n    if (start.offset != 0) {\n      change.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    // Update our variables with the new value.\n    document = change.value.document\n    startText = document.getDescendant(start.key)\n    startBlock = document.getClosestBlock(start.key)\n    startChild = startBlock.getFurthestAncestor(startText.key)\n\n    // If the first and last block aren't the same, we need to move any of the\n    // starting block's children after the split into the last block of the\n    // fragment, which has already been inserted.\n    if (firstBlock != lastBlock) {\n      const nextChild = isAtStart\n        ? startChild\n        : startBlock.getNextSibling(startChild.key)\n      const nextNodes = nextChild\n        ? startBlock.nodes.skipUntil(n => n.key == nextChild.key)\n        : List()\n      const lastIndex = lastBlock.nodes.size\n\n      nextNodes.forEach((node, i) => {\n        const newIndex = lastIndex + i\n        change.moveNodeByKey(node.key, lastBlock.key, newIndex)\n      })\n    }\n\n    // If the starting block is empty, we replace it entirely with the first block\n    // of the fragment, since this leads to a more expected behavior for the user.\n    if (!change.isVoid(startBlock) && startBlock.text === '') {\n      change.removeNodeByKey(startBlock.key)\n      change.insertNodeByKey(parent.key, index, firstBlock)\n    } else {\n      // Otherwise, we maintain the starting block, and insert all of the first\n      // block's inline nodes into it at the split point.\n      const inlineChild = startBlock.getFurthestAncestor(startText.key)\n      const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n      firstBlock.nodes.forEach((inline, i) => {\n        const o = start.offset == 0 ? 0 : 1\n        const newIndex = inlineIndex + i + o\n        change.insertNodeByKey(startBlock.key, newIndex, inline)\n      })\n    }\n  })\n}\n\nconst findInsertionNode = (fragment, document, startKey) => {\n  const hasSingleNode = object => object && object.nodes.size === 1\n  const firstNode = object => object && object.nodes.first()\n  let node = fragment\n\n  if (hasSingleNode(fragment)) {\n    let fragmentInner = firstNode(fragment)\n\n    const matches = documentNode => documentNode.type === fragmentInner.type\n    let documentInner = document.getFurthest(startKey, matches)\n\n    if (documentInner === document.getParent(startKey)) node = fragmentInner\n\n    while (hasSingleNode(fragmentInner) && hasSingleNode(documentInner)) {\n      fragmentInner = firstNode(fragmentInner)\n      documentInner = firstNode(documentInner)\n\n      if (fragmentInner.type === documentInner.type) {\n        node = fragmentInner\n      } else {\n        break\n      }\n    }\n  }\n\n  return node\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n */\n\nCommands.insertInlineAtRange = (change, range, inline) => {\n  inline = Inline.create(inline)\n\n  change.withoutNormalizing(() => {\n    if (range.isExpanded) {\n      change.deleteAtRange(range)\n      range = range.moveToStart()\n    }\n\n    const { value } = change\n    const { document } = value\n    const { start } = range\n    const parent = document.getParent(start.key)\n    const startText = document.assertDescendant(start.key)\n    const index = parent.nodes.indexOf(startText)\n\n    if (change.isVoid(parent)) return\n\n    change.splitNodeByKey(start.key, start.offset)\n    change.insertNodeByKey(parent.key, index + 1, inline)\n  })\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextAtRange = (change, range, text, marks) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  let key = start.key\n  const offset = start.offset\n  const path = start.path\n  const parent = document.getParent(start.key)\n\n  if (change.isVoid(parent)) {\n    return\n  }\n\n  change.withoutNormalizing(() => {\n    if (range.isExpanded) {\n      change.deleteAtRange(range)\n\n      const startText = change.value.document.getNode(path)\n\n      // Update range start after delete\n      if (startText && startText.key !== key) {\n        key = startText.key\n      }\n    }\n\n    change.insertTextByKey(key, offset, text, marks)\n  })\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n */\n\nCommands.removeMarkAtRange = (change, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { start, end } = range\n\n  change.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key == start.key) index = start.offset\n      if (key == end.key) length = end.offset\n      if (key == start.key && key == end.key) length = end.offset - start.offset\n\n      change.removeMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setBlocksAtRange = (change, range, properties) => {\n  const { editor, value } = change\n  const { document } = value\n  const blocks = document.getBlocksAtRange(range)\n\n  const { start, end, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(start.key, editor)\n  const startBlock = document.getClosestBlock(start.key)\n  const endBlock = document.getClosestBlock(end.key)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed == false &&\n    start.offset == 0 &&\n    end.offset == 0 &&\n    isStartVoid == false &&\n    start.key == startBlock.getFirstText().key &&\n    end.key == endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  change.withoutNormalizing(() => {\n    sets.forEach(block => {\n      change.setNodeByKey(block.key, properties)\n    })\n  })\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setInlinesAtRange = (change, range, properties) => {\n  const { value } = change\n  const { document } = value\n  const inlines = document.getInlinesAtRange(range)\n\n  change.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      change.setNodeByKey(inline.key, properties)\n    })\n  })\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitBlockAtRange = (change, range, height = 1) => {\n  const { start, end } = range\n  let { value } = change\n  let { document } = value\n  let node = document.assertDescendant(start.key)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  change.withoutNormalizing(() => {\n    change.splitDescendantsByKey(node.key, start.key, start.offset)\n\n    value = change.value\n    document = value.document\n\n    if (range.isExpanded) {\n      if (range.isBackward) range = range.flip()\n      const nextBlock = document.getNextBlock(node.key)\n      range = range.moveAnchorToStartOfNode(nextBlock)\n      range = range.setFocus(range.focus.setPath(null))\n\n      if (start.key === end.key) {\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset)\n      }\n\n      range = document.resolveRange(range)\n      change.deleteAtRange(range)\n    }\n  })\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitInlineAtRange = (change, range, height = Infinity) => {\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    range = range.moveToStart()\n  }\n\n  const { start } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(start.key)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, start.key, start.offset)\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.toggleMarkAtRange = (change, range, mark) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const { value } = change\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark)\n  } else {\n    change.addMarkAtRange(range, mark)\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapBlockAtRange = (change, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = change\n  let { document } = value\n  const blocks = document.getBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object != 'block') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  change.withoutNormalizing(() => {\n    wrappers.forEach(block => {\n      const first = block.nodes.first()\n      const last = block.nodes.last()\n      const parent = document.getParent(block.key)\n      const index = parent.nodes.indexOf(block)\n\n      const children = block.nodes.filter(child => {\n        return blocks.some(b => child == b || child.hasDescendant(b.key))\n      })\n\n      const firstMatch = children.first()\n      const lastMatch = children.last()\n\n      if (first == firstMatch && last == lastMatch) {\n        block.nodes.forEach((child, i) => {\n          change.moveNodeByKey(child.key, parent.key, index + i)\n        })\n\n        change.removeNodeByKey(block.key)\n      } else if (last == lastMatch) {\n        block.nodes.skipUntil(n => n == firstMatch).forEach((child, i) => {\n          change.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      } else if (first == firstMatch) {\n        block.nodes\n          .takeUntil(n => n == lastMatch)\n          .push(lastMatch)\n          .forEach((child, i) => {\n            change.moveNodeByKey(child.key, parent.key, index + i)\n          })\n      } else {\n        const firstText = firstMatch.getFirstText()\n\n        change.splitDescendantsByKey(block.key, firstText.key, 0)\n\n        document = change.value.document\n\n        children.forEach((child, i) => {\n          if (i == 0) {\n            const extra = child\n            child = document.getNextBlock(child.key)\n            change.removeNodeByKey(extra.key)\n          }\n\n          change.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      }\n    })\n  })\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapInlineAtRange = (change, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object != 'inline') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  change.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      const parent = change.value.document.getParent(inline.key)\n      const index = parent.nodes.indexOf(inline)\n\n      inline.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + i)\n      })\n\n      change.removeNodeByKey(inline.key)\n    })\n  })\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockAtRange = (change, range, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const { value } = change\n  const { document } = value\n\n  const blocks = document.getBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 == p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  change.withoutNormalizing(() => {\n    // Inject the new block node into the parent.\n    change.insertNodeByKey(parent.key, index, block)\n\n    // Move the sibling nodes into the new block node.\n    siblings.forEach((node, i) => {\n      change.moveNodeByKey(node.key, block.key, i)\n    })\n  })\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n */\n\nCommands.wrapInlineAtRange = (change, range, inline) => {\n  const { value } = change\n  let { document } = value\n  const { start, end } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(start.key)\n\n    if (!change.isVoid(inlineParent)) {\n      return\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(start.key)\n  let endBlock = document.getClosestBlock(end.key)\n  const startInline = document.getClosestInline(start.key)\n  const endInline = document.getClosestInline(end.key)\n  let startChild = startBlock.getFurthestAncestor(start.key)\n  let endChild = endBlock.getFurthestAncestor(end.key)\n\n  change.withoutNormalizing(() => {\n    if (!startInline || startInline != endInline) {\n      change.splitDescendantsByKey(endChild.key, end.key, end.offset)\n      change.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    document = change.value.document\n    startBlock = document.getDescendant(startBlock.key)\n    endBlock = document.getDescendant(endBlock.key)\n    startChild = startBlock.getFurthestAncestor(start.key)\n    endChild = endBlock.getFurthestAncestor(end.key)\n    const startIndex = startBlock.nodes.indexOf(startChild)\n    const endIndex = endBlock.nodes.indexOf(endChild)\n\n    if (startInline && startInline == endInline) {\n      const text = startBlock\n        .getTextsAtRange(range)\n        .get(0)\n        .splitText(start.offset)[1]\n        .splitText(end.offset - start.offset)[0]\n\n      inline = inline.set('nodes', List([text]))\n      change.insertInlineAtRange(range, inline)\n\n      const inlinekey = inline.getFirstText().key\n      const rng = {\n        anchor: {\n          key: inlinekey,\n          offset: 0,\n        },\n        focus: {\n          key: inlinekey,\n          offset: end.offset - start.offset,\n        },\n        isFocused: true,\n      }\n      change.select(rng)\n    } else if (startBlock == endBlock) {\n      document = change.value.document\n      startBlock = document.getClosestBlock(start.key)\n      startChild = startBlock.getFurthestAncestor(start.key)\n\n      const startInner = document.getNextSibling(startChild.key)\n      const startInnerIndex = startBlock.nodes.indexOf(startInner)\n      const endInner =\n        start.key == end.key\n          ? startInner\n          : startBlock.getFurthestAncestor(end.key)\n      const inlines = startBlock.nodes\n        .skipUntil(n => n == startInner)\n        .takeUntil(n => n == endInner)\n        .push(endInner)\n\n      const node = inline.regenerateKey()\n\n      change.insertNodeByKey(startBlock.key, startInnerIndex, node)\n\n      inlines.forEach((child, i) => {\n        change.moveNodeByKey(child.key, node.key, i)\n      })\n    } else {\n      const startInlines = startBlock.nodes.slice(startIndex + 1)\n      const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n      const startNode = inline.regenerateKey()\n      const endNode = inline.regenerateKey()\n\n      change.insertNodeByKey(startBlock.key, startIndex + 1, startNode)\n      change.insertNodeByKey(endBlock.key, endIndex, endNode)\n\n      startInlines.forEach((child, i) => {\n        change.moveNodeByKey(child.key, startNode.key, i)\n      })\n\n      endInlines.forEach((child, i) => {\n        change.moveNodeByKey(child.key, endNode.key, i)\n      })\n\n      blocks.slice(1, -1).forEach(block => {\n        const node = inline.regenerateKey()\n        change.insertNodeByKey(block.key, 0, node)\n\n        block.nodes.forEach((child, i) => {\n          change.moveNodeByKey(child.key, node.key, i)\n        })\n      })\n    }\n  })\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n */\n\nCommands.wrapTextAtRange = (change, range, prefix, suffix = prefix) => {\n  const { start, end } = range\n  const startRange = range.moveToStart()\n  let endRange = range.moveToEnd()\n\n  if (start.key == end.key) {\n    endRange = endRange.moveForward(prefix.length)\n  }\n\n  change.withoutNormalizing(() => {\n    change.insertTextAtRange(startRange, prefix, [])\n    change.insertTextAtRange(endRange, suffix, [])\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nCommands.addMarkByPath = (change, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'add_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n */\n\nCommands.insertFragmentByPath = (change, path, index, fragment) => {\n  fragment.nodes.forEach((node, i) => {\n    change.insertNodeByPath(path, index + i, node)\n  })\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\nCommands.insertNodeByPath = (change, path, index, node) => {\n  const { value } = change\n\n  change.applyOperation({\n    type: 'insert_node',\n    value,\n    path: path.concat(index),\n    node,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextByPath = (change, path, offset, text, marks) => {\n  const { value } = change\n  const { decorations, document } = value\n  const node = document.assertNode(path)\n  marks = marks || node.getMarksAtIndex(offset)\n\n  let updated = false\n  const { key } = node\n\n  const decs = decorations.filter(dec => {\n    const { start, end, mark } = dec\n    const isAtomic = change.isAtomic(mark)\n    if (!isAtomic) return true\n    if (start.key !== key) return true\n\n    if (start.offset < offset && (end.key !== key || end.offset > offset)) {\n      updated = true\n      return false\n    }\n\n    return true\n  })\n\n  if (updated) {\n    change.setValue({ decorations: decs })\n  }\n\n  change.applyOperation({\n    type: 'insert_text',\n    value,\n    path,\n    offset,\n    text,\n    marks,\n  })\n}\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nCommands.mergeNodeByPath = (change, path) => {\n  const { value } = change\n  const { document } = value\n  const original = document.getDescendant(path)\n  const previous = document.getPreviousSibling(path)\n\n  if (!previous) {\n    throw new Error(\n      `Unable to merge node with path \"${path}\", because it has no previous sibling.`\n    )\n  }\n\n  const position =\n    previous.object == 'text' ? previous.text.length : previous.nodes.size\n\n  change.applyOperation({\n    type: 'merge_node',\n    value,\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n}\n\n/**\n * Move a node by `path` to a new parent by `newPath` and `index`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} newPath\n * @param {Number} index\n */\n\nCommands.moveNodeByPath = (change, path, newPath, newIndex) => {\n  const { value } = change\n\n  // If the operation path and newPath are the same,\n  // this should be considered a NOOP\n  if (PathUtils.isEqual(path, newPath)) {\n    return change\n  }\n\n  change.applyOperation({\n    type: 'move_node',\n    value,\n    path,\n    newPath: newPath.concat(newIndex),\n  })\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nCommands.removeMarkByPath = (change, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'remove_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n}\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nCommands.removeAllMarksByPath = (change, path) => {\n  const { state } = change\n  const { document } = state\n  const node = document.assertNode(path)\n  const texts = node.object === 'text' ? [node] : node.getTextsAsArray()\n\n  texts.forEach(text => {\n    text.getMarksAsArray().forEach(mark => {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark)\n    })\n  })\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nCommands.removeNodeByPath = (change, path) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n\n  change.applyOperation({\n    type: 'remove_node',\n    value,\n    path,\n    node,\n  })\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\nCommands.removeTextByPath = (change, path, offset, length) => {\n  const { value } = change\n  const { decorations, document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n  const { text } = node\n\n  let updated = false\n  const { key } = node\n  const from = offset\n  const to = offset + length\n\n  const decs = decorations.filter(dec => {\n    const { start, end, mark } = dec\n    const isAtomic = change.isAtomic(mark)\n    if (!isAtomic) return true\n    if (start.key !== key) return true\n\n    if (start.offset < from && (end.key !== key || end.offset > from)) {\n      updated = true\n      return false\n    }\n\n    if (start.offset < to && (end.key !== key || end.offset > to)) {\n      updated = true\n      return null\n    }\n\n    return true\n  })\n\n  if (updated) {\n    change.setValue({ decorations: decs })\n  }\n\n  const removals = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n    const string = text.slice(start, end)\n\n    removals.push({\n      type: 'remove_text',\n      value,\n      path,\n      offset: start,\n      text: string,\n      marks: leaf.marks,\n    })\n  })\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse())\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|Node} node\n */\n\nCommands.replaceNodeByPath = (change, path, newNode) => {\n  newNode = Node.create(newNode)\n  const index = path.last()\n  const parentPath = PathUtils.lift(path)\n\n  change.withoutNormalizing(() => {\n    change.removeNodeByPath(path)\n    change.insertNodeByPath(parentPath, index, newNode)\n  })\n}\n\n/**\n * Replace A Length of Text with another string or text\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.replaceTextByPath = (change, path, offset, length, text, marks) => {\n  const { document } = change.value\n  const node = document.assertNode(path)\n\n  if (length + offset > node.text.length) {\n    length = node.text.length - offset\n  }\n\n  const range = document.createRange({\n    anchor: { path, offset },\n    focus: { path, offset: offset + length },\n  })\n\n  let activeMarks = document.getActiveMarksAtRange(range)\n\n  change.withoutNormalizing(() => {\n    change.removeTextByPath(path, offset, length)\n\n    if (!marks) {\n      // Do not use mark at index when marks and activeMarks are both empty\n      marks = activeMarks ? activeMarks : []\n    } else if (activeMarks) {\n      // Do not use `has` because we may want to reset marks like font-size with\n      // an updated data;\n      activeMarks = activeMarks.filter(\n        activeMark => !marks.find(m => activeMark.type === m.type)\n      )\n\n      marks = activeMarks.merge(marks)\n    }\n\n    change.insertTextByPath(path, offset, text, marks)\n  })\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nCommands.setMarkByPath = (change, path, offset, length, mark, properties) => {\n  mark = Mark.create(mark)\n  properties = Mark.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation({\n    type: 'set_mark',\n    value,\n    path,\n    offset,\n    length,\n    mark,\n    properties,\n  })\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.setNodeByPath = (change, path, properties) => {\n  properties = Node.createProperties(properties)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n\n  change.applyOperation({\n    type: 'set_node',\n    value,\n    path,\n    node,\n    properties,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.setTextByPath = (change, path, text, marks) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const end = node.text.length\n  change.replaceTextByPath(path, 0, end, text, marks)\n}\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nCommands.splitNodeByPath = (change, path, position, options = {}) => {\n  const { target = null } = options\n  const { value } = change\n  const { document } = value\n  const node = document.getDescendant(path)\n\n  change.applyOperation({\n    type: 'split_node',\n    value,\n    path,\n    position,\n    target,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n  })\n}\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n */\n\nCommands.splitDescendantsByPath = (change, path, textPath, textOffset) => {\n  if (path.equals(textPath)) {\n    change.splitNodeByPath(textPath, textOffset)\n    return\n  }\n\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const text = document.assertNode(textPath)\n  const ancestors = document.getAncestors(textPath)\n  const nodes = ancestors\n    .skipUntil(a => a.key == node.key)\n    .reverse()\n    .unshift(text)\n\n  let previous\n  let index\n\n  change.withoutNormalizing(() => {\n    nodes.forEach(n => {\n      const prevIndex = index == null ? null : index\n      index = previous ? n.nodes.indexOf(previous) + 1 : textOffset\n      previous = n\n      change.splitNodeByKey(n.key, index, { target: prevIndex })\n    })\n  })\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapInlineByPath = (change, path, properties) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  change.unwrapInlineAtRange(range, properties)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapBlockByPath = (change, path, properties) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  change.unwrapBlockAtRange(range, properties)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nCommands.unwrapNodeByPath = (change, path) => {\n  const { value } = change\n  const { document } = value\n  document.assertNode(path)\n\n  const parentPath = PathUtils.lift(path)\n  const parent = document.assertNode(parentPath)\n  const index = path.last()\n  const parentIndex = parentPath.last()\n  const grandPath = PathUtils.lift(parentPath)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  change.withoutNormalizing(() => {\n    if (parent.nodes.size === 1) {\n      change.moveNodeByPath(path, grandPath, parentIndex + 1)\n      change.removeNodeByPath(parentPath)\n    } else if (isFirst) {\n      change.moveNodeByPath(path, grandPath, parentIndex)\n    } else if (isLast) {\n      change.moveNodeByPath(path, grandPath, parentIndex + 1)\n    } else {\n      let updatedPath = PathUtils.increment(path, 1, parentPath.size - 1)\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0)\n      change.splitNodeByPath(parentPath, index)\n      change.moveNodeByPath(updatedPath, grandPath, parentIndex + 1)\n    }\n  })\n}\n\n/**\n * Unwrap all of the children of a node, by removing the node and replacing it\n * with the children in the tree.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nCommands.unwrapChildrenByPath = (change, path) => {\n  path = PathUtils.create(path)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const { nodes } = node\n\n  change.withoutNormalizing(() => {\n    nodes.reverse().forEach((child, i) => {\n      const childIndex = nodes.size - i - 1\n      const childPath = path.push(childIndex)\n      change.moveNodeByPath(childPath, parentPath, index + 1)\n    })\n\n    change.removeNodeByPath(path)\n  })\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockByPath = (change, path, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  change.withoutNormalizing(() => {\n    change.insertNodeByPath(parentPath, index, block)\n    change.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} inline\n */\n\nCommands.wrapInlineByPath = (change, path, inline) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  change.withoutNormalizing(() => {\n    change.insertNodeByPath(parentPath, index, inline)\n    change.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Node|Object} node\n */\n\nCommands.wrapNodeByPath = (change, path, node) => {\n  node = Node.create(node)\n\n  if (node.object === 'block') {\n    change.wrapBlockByPath(path, node)\n  } else if (node.object === 'inline') {\n    change.wrapInlineByPath(path, node)\n  }\n}\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nconst COMMANDS = [\n  'addMark',\n  'insertFragment',\n  'insertNode',\n  'insertText',\n  'mergeNode',\n  'removeAllMarks',\n  'removeMark',\n  'removeNode',\n  'removeText',\n  'replaceNode',\n  'replaceText',\n  'setMark',\n  'setNode',\n  'setText',\n  'splitNode',\n  'unwrapBlock',\n  'unwrapChildren',\n  'unwrapInline',\n  'unwrapNode',\n  'wrapBlock',\n  'wrapInline',\n  'wrapNode',\n]\n\nfor (const method of COMMANDS) {\n  Commands[`${method}ByKey`] = (change, key, ...args) => {\n    const { value } = change\n    const { document } = value\n    const path = document.assertPath(key)\n    change[`${method}ByPath`](path, ...args)\n  }\n}\n\n// Moving nodes takes two keys, so it's slightly different.\nCommands.moveNodeByKey = (change, key, newKey, ...args) => {\n  const { value } = change\n  const { document } = value\n  const path = document.assertPath(key)\n  const newPath = document.assertPath(newKey)\n  change.moveNodeByPath(path, newPath, ...args)\n}\n\n// Splitting descendants takes two keys, so it's slightly different.\nCommands.splitDescendantsByKey = (change, key, textKey, ...args) => {\n  const { value } = change\n  const { document } = value\n  const path = document.assertPath(key)\n  const textPath = document.assertPath(textKey)\n  change.splitDescendantsByPath(path, textPath, ...args)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","/**\n * A plugin that adds a set of commands to the editor.\n *\n * @param {Object} commands\n * @return {Object}\n */\n\nfunction CommandsPlugin(commands = {}) {\n  /**\n   * On command, if it exists in our list of commands, call it.\n   *\n   * @param {Object} command\n   * @param {Change} change\n   * @param {Function} next\n   */\n\n  function onCommand(command, change, next) {\n    const { type, args } = command\n    const fn = commands[type]\n    if (!fn) return next()\n    change.call(fn, ...args)\n  }\n\n  /**\n   * On construct, register all the commands.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const command in commands) {\n      editor.registerCommand(command)\n    }\n\n    return next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onCommand,\n    onConstruct,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CommandsPlugin\n","import omit from 'lodash/omit'\nimport { List } from 'immutable'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Save an `operation` into the history.\n *\n * @param {Change} change\n * @param {Object} operation\n */\n\nCommands.save = (change, operation) => {\n  const { operations, value } = change\n  const { data } = value\n  let { save, merge } = change.tmp\n  if (save === false) return\n\n  let undos = data.get('undos') || List()\n  const lastBatch = undos.last()\n  const lastOperation = lastBatch && lastBatch.last()\n\n  // If `merge` is non-commital, and this is not the first operation in a new\n  // change, then merge, otherwise merge based on the last operation.\n  if (merge == null) {\n    if (operations.size !== 0) {\n      merge = true\n    } else {\n      merge = shouldMerge(operation, lastOperation)\n    }\n  }\n\n  // If the `merge` flag is true, add the operation to the last batch.\n  if (merge && lastBatch) {\n    const batch = lastBatch.push(operation)\n    undos = undos.pop()\n    undos = undos.push(batch)\n  } else {\n    // Otherwise, create a new batch with the operation.\n    const batch = List([operation])\n    undos = undos.push(batch)\n  }\n\n  // Constrain the history to 100 entries for memory's sake.\n  if (undos.size > 100) {\n    undos = undos.takeLast(100)\n  }\n\n  // Clear the redos and update the history.\n  change.withoutSaving(() => {\n    const redos = List()\n    const newData = data.set('undos', undos).set('redos', redos)\n    change.setValue({ data: newData })\n  })\n}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nCommands.redo = change => {\n  const { value } = change\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = redos.last()\n  if (!batch) return\n\n  change.withoutSaving(() => {\n    // Replay the batch of operations.\n    batch.forEach(op => {\n      const { type, properties } = op\n\n      // When the operation mutates the selection, omit its `isFocused` value to\n      // prevent the editor focus from changing during redoing.\n      if (type === 'set_selection') {\n        op = op.set('properties', omit(properties, 'isFocused'))\n      }\n\n      change.applyOperation(op)\n    })\n\n    // Shift the next value into the undo stack.\n    redos = redos.pop()\n    undos = undos.push(batch)\n    const newData = data.set('undos', undos).set('redos', redos)\n    change.setValue({ data: newData })\n  })\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nCommands.undo = change => {\n  const { value } = change\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = undos.last()\n  if (!batch) return\n\n  change.withoutSaving(() => {\n    // Replay the inverse of the previous operations.\n    batch\n      .slice()\n      .reverse()\n      .map(op => op.invert())\n      .forEach(inverse => {\n        const { type, properties } = inverse\n\n        // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during undoing.\n        if (type === 'set_selection') {\n          inverse = inverse.set('properties', omit(properties, 'isFocused'))\n        }\n\n        change.applyOperation(inverse)\n      })\n\n    // Shift the previous operations into the redo stack.\n    redos = redos.push(batch)\n    undos = undos.pop()\n    const newData = data.set('undos', undos).set('redos', redos)\n    change.setValue({ data: newData })\n  })\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without merging any of\n * the new operations into previous save point in the history.\n *\n * @param {Change} change\n * @param {Function} fn\n */\n\nCommands.withoutMerging = (change, fn) => {\n  const value = change.tmp.merge\n  change.tmp.merge = false\n  fn(change)\n  change.tmp.merge = value\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without saving any of\n * their operations into the history.\n *\n * @param {Change}\n * @param {Function} fn\n */\n\nCommands.withoutSaving = (change, fn) => {\n  const value = change.tmp.save\n  change.tmp.save = false\n  fn(change)\n  change.tmp.save = value\n}\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type === 'set_selection' && p.type === 'set_selection') ||\n    (o.type === 'insert_text' &&\n      p.type === 'insert_text' &&\n      o.offset === p.offset + p.text.length &&\n      o.path.equals(p.path)) ||\n    (o.type === 'remove_text' &&\n      p.type === 'remove_text' &&\n      o.offset + o.text.length === p.offset &&\n      o.path.equals(p.path))\n\n  return merge\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import { is } from 'immutable'\nimport pick from 'lodash/pick'\n\nimport Selection from '../models/selection'\nimport TextUtils from '../utils/text-utils'\n\nconst Commands = {}\n\nCommands.blur = change => {\n  change.select({ isFocused: false })\n}\n\nCommands.deselect = change => {\n  const range = Selection.create()\n  change.select(range)\n}\n\nCommands.focus = change => {\n  change.select({ isFocused: true })\n}\n\nCommands.flip = change => {\n  change.call(proxy, 'flip')\n}\n\nCommands.moveAnchorBackward = (change, ...args) => {\n  change.call(pointBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordBackward = (change, ...args) => {\n  change.call(pointWordBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorForward = (change, ...args) => {\n  change.call(pointForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordForward = (change, ...args) => {\n  change.call(pointWordForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorTo = (change, ...args) => {\n  change.call(proxy, 'moveAnchorTo', ...args)\n}\n\nCommands.moveAnchorToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'anchor', 'end', 'block')\n}\n\nCommands.moveAnchorToEndOfInline = change => {\n  change.call(pointEdgeObject, 'anchor', 'end', 'inline')\n}\n\nCommands.moveAnchorToEndOfDocument = change => {\n  change.moveAnchorToEndOfNode(change.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'next', 'block')\n}\n\nCommands.moveAnchorToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline')\n}\n\nCommands.moveAnchorToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'next', 'text')\n}\n\nCommands.moveAnchorToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveAnchorToEndOfNode', ...args)\n}\n\nCommands.moveAnchorToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block')\n}\n\nCommands.moveAnchorToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline')\n}\n\nCommands.moveAnchorToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text')\n}\n\nCommands.moveAnchorToEndOfText = change => {\n  change.call(pointEdgeObject, 'anchor', 'end', 'text')\n}\n\nCommands.moveAnchorToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'anchor', 'start', 'block')\n}\n\nCommands.moveAnchorToStartOfDocument = change => {\n  change.moveAnchorToStartOfNode(change.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToStartOfInline = change => {\n  change.call(pointEdgeObject, 'anchor', 'start', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'next', 'block')\n}\n\nCommands.moveAnchorToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'next', 'text')\n}\n\nCommands.moveAnchorToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveAnchorToStartOfNode', ...args)\n}\n\nCommands.moveAnchorToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block')\n}\n\nCommands.moveAnchorToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline')\n}\n\nCommands.moveAnchorToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text')\n}\n\nCommands.moveAnchorToStartOfText = change => {\n  change.call(pointEdgeObject, 'anchor', 'start', 'text')\n}\n\nCommands.moveBackward = (change, ...args) => {\n  change.moveAnchorBackward(...args).moveFocusBackward(...args)\n}\n\nCommands.moveWordBackward = (change, ...args) => {\n  change.moveFocusWordBackward(...args).moveToFocus()\n}\n\nCommands.moveEndBackward = (change, ...args) => {\n  change.call(pointBackward, 'end', ...args)\n}\n\nCommands.moveEndWordBackward = (change, ...args) => {\n  change.call(pointWordBackward, 'end', ...args)\n}\n\nCommands.moveEndForward = (change, ...args) => {\n  change.call(pointForward, 'end', ...args)\n}\n\nCommands.moveEndWordForward = (change, ...args) => {\n  change.call(pointWordForward, 'end', ...args)\n}\n\nCommands.moveEndTo = (change, ...args) => {\n  change.call(proxy, 'moveEndTo', ...args)\n}\n\nCommands.moveEndToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'end', 'end', 'block')\n}\n\nCommands.moveEndToEndOfDocument = change => {\n  change.moveEndToEndOfNode(change.value.document).moveToEnd()\n}\n\nCommands.moveEndToEndOfInline = change => {\n  change.call(pointEdgeObject, 'end', 'end', 'inline')\n}\n\nCommands.moveEndToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'next', 'block')\n}\n\nCommands.moveEndToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'next', 'inline')\n}\n\nCommands.moveEndToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'next', 'text')\n}\n\nCommands.moveEndToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveEndToEndOfNode', ...args)\n}\n\nCommands.moveEndToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'previous', 'block')\n}\n\nCommands.moveEndToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'previous', 'inline')\n}\n\nCommands.moveEndToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'previous', 'text')\n}\n\nCommands.moveEndToEndOfText = change => {\n  change.call(pointEdgeObject, 'end', 'end', 'text')\n}\n\nCommands.moveEndToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'end', 'start', 'block')\n}\n\nCommands.moveEndToStartOfDocument = change => {\n  change.moveEndToStartOfNode(change.value.document).moveToEnd()\n}\n\nCommands.moveEndToStartOfInline = change => {\n  change.call(pointEdgeObject, 'end', 'start', 'inline')\n}\n\nCommands.moveEndToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'next', 'block')\n}\n\nCommands.moveEndToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'next', 'inline')\n}\n\nCommands.moveEndToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'next', 'text')\n}\n\nCommands.moveEndToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveEndToStartOfNode', ...args)\n}\n\nCommands.moveEndToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'previous', 'block')\n}\n\nCommands.moveEndToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'previous', 'inline')\n}\n\nCommands.moveEndToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'previous', 'text')\n}\n\nCommands.moveEndToStartOfText = change => {\n  change.call(pointEdgeObject, 'end', 'start', 'text')\n}\n\nCommands.moveFocusBackward = (change, ...args) => {\n  change.call(pointBackward, 'focus', ...args)\n}\n\nCommands.moveFocusWordBackward = (change, ...args) => {\n  change.call(pointWordBackward, 'focus', ...args)\n}\n\nCommands.moveFocusForward = (change, ...args) => {\n  change.call(pointForward, 'focus', ...args)\n}\n\nCommands.moveFocusWordForward = (change, ...args) => {\n  change.call(pointWordForward, 'focus', ...args)\n}\n\nCommands.moveFocusTo = (change, ...args) => {\n  change.call(proxy, 'moveFocusTo', ...args)\n}\n\nCommands.moveFocusToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'focus', 'end', 'block')\n}\n\nCommands.moveFocusToEndOfDocument = change => {\n  change.moveFocusToEndOfNode(change.value.document).moveToFocus()\n}\n\nCommands.moveFocusToEndOfInline = change => {\n  change.call(pointEdgeObject, 'focus', 'end', 'inline')\n}\n\nCommands.moveFocusToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'next', 'block')\n}\n\nCommands.moveFocusToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'next', 'inline')\n}\n\nCommands.moveFocusToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'next', 'text')\n}\n\nCommands.moveFocusToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveFocusToEndOfNode', ...args)\n}\n\nCommands.moveFocusToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'previous', 'block')\n}\n\nCommands.moveFocusToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline')\n}\n\nCommands.moveFocusToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'previous', 'text')\n}\n\nCommands.moveFocusToEndOfText = change => {\n  change.call(pointEdgeObject, 'focus', 'end', 'text')\n}\n\nCommands.moveFocusToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'focus', 'start', 'block')\n}\n\nCommands.moveFocusToStartOfDocument = change => {\n  change.moveFocusToStartOfNode(change.value.document).moveToFocus()\n}\n\nCommands.moveFocusToStartOfInline = change => {\n  change.call(pointEdgeObject, 'focus', 'start', 'inline')\n}\n\nCommands.moveFocusToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'next', 'block')\n}\n\nCommands.moveFocusToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'next', 'inline')\n}\n\nCommands.moveFocusToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'next', 'text')\n}\n\nCommands.moveFocusToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveFocusToStartOfNode', ...args)\n}\n\nCommands.moveFocusToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'previous', 'block')\n}\n\nCommands.moveFocusToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline')\n}\n\nCommands.moveFocusToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'previous', 'text')\n}\n\nCommands.moveFocusToStartOfText = change => {\n  change.call(pointEdgeObject, 'focus', 'start', 'text')\n}\n\nCommands.moveForward = (change, ...args) => {\n  change.moveAnchorForward(...args).moveFocusForward(...args)\n}\n\nCommands.moveWordForward = (change, ...args) => {\n  change.moveFocusWordForward(...args).moveToFocus(...args)\n}\n\nCommands.moveStartBackward = (change, ...args) => {\n  change.call(pointBackward, 'start', ...args)\n}\n\nCommands.moveStartWordBackward = (change, ...args) => {\n  change.call(pointWordBackward, 'start', ...args)\n}\n\nCommands.moveStartForward = (change, ...args) => {\n  change.call(pointForward, 'start', ...args)\n}\n\nCommands.moveStartWordForward = (change, ...args) => {\n  change.call(pointWordForward, 'start', ...args)\n}\n\nCommands.moveStartTo = (change, ...args) => {\n  change.call(proxy, 'moveStartTo', ...args)\n}\n\nCommands.moveStartToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'start', 'end', 'block')\n}\n\nCommands.moveStartToEndOfDocument = change => {\n  change.moveStartToEndOfNode(change.value.document).moveToStart()\n}\n\nCommands.moveStartToEndOfInline = change => {\n  change.call(pointEdgeObject, 'start', 'end', 'inline')\n}\n\nCommands.moveStartToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'next', 'block')\n}\n\nCommands.moveStartToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'next', 'inline')\n}\n\nCommands.moveStartToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'next', 'text')\n}\n\nCommands.moveStartToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveStartToEndOfNode', ...args)\n}\n\nCommands.moveStartToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'previous', 'block')\n}\n\nCommands.moveStartToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'previous', 'inline')\n}\n\nCommands.moveStartToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'previous', 'text')\n}\n\nCommands.moveStartToEndOfText = change => {\n  change.call(pointEdgeObject, 'start', 'end', 'text')\n}\n\nCommands.moveStartToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'start', 'start', 'block')\n}\n\nCommands.moveStartToStartOfDocument = change => {\n  change.moveStartToStartOfNode(change.value.document).moveToStart()\n}\n\nCommands.moveStartToStartOfInline = change => {\n  change.call(pointEdgeObject, 'start', 'start', 'inline')\n}\n\nCommands.moveStartToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'next', 'block')\n}\n\nCommands.moveStartToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'next', 'inline')\n}\n\nCommands.moveStartToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'next', 'text')\n}\n\nCommands.moveStartToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveStartToStartOfNode', ...args)\n}\n\nCommands.moveStartToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'previous', 'block')\n}\n\nCommands.moveStartToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'previous', 'inline')\n}\n\nCommands.moveStartToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'previous', 'text')\n}\n\nCommands.moveStartToStartOfText = change => {\n  change.call(pointEdgeObject, 'start', 'start', 'text')\n}\n\nCommands.moveTo = (change, ...args) => {\n  change.call(proxy, 'moveTo', ...args)\n}\n\nCommands.moveToAnchor = change => {\n  change.call(proxy, 'moveToAnchor')\n}\n\nCommands.moveToEnd = change => {\n  change.call(proxy, 'moveToEnd')\n}\n\nCommands.moveToEndOfBlock = change => {\n  change.moveEndToEndOfBlock().moveToEnd()\n}\n\nCommands.moveToEndOfDocument = change => {\n  change.moveEndToEndOfNode(change.value.document).moveToEnd()\n}\n\nCommands.moveToEndOfInline = change => {\n  change.moveEndToEndOfInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextBlock = change => {\n  change.moveEndToEndOfNextBlock().moveToEnd()\n}\n\nCommands.moveToEndOfNextInline = change => {\n  change.moveEndToEndOfNextInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextText = change => {\n  change.moveEndToEndOfNextText().moveToEnd()\n}\n\nCommands.moveToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveToEndOfNode', ...args)\n}\n\nCommands.moveToEndOfPreviousBlock = change => {\n  change.moveStartToEndOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToEndOfPreviousInline = change => {\n  change.moveStartToEndOfPreviousInline().moveToStart()\n}\n\nCommands.moveToEndOfPreviousText = change => {\n  change.moveStartToEndOfPreviousText().moveToStart()\n}\n\nCommands.moveToEndOfText = change => {\n  change.moveEndToEndOfText().moveToEnd()\n}\n\nCommands.moveToFocus = change => {\n  change.call(proxy, 'moveToFocus')\n}\n\nCommands.moveToRangeOfDocument = change => {\n  change.moveToRangeOfNode(change.value.document)\n}\n\nCommands.moveToRangeOfNode = (change, ...args) => {\n  change.call(proxy, 'moveToRangeOfNode', ...args)\n}\n\nCommands.moveToStart = change => {\n  change.call(proxy, 'moveToStart')\n}\n\nCommands.moveToStartOfBlock = change => {\n  change.moveStartToStartOfBlock().moveToStart()\n}\n\nCommands.moveToStartOfDocument = change => {\n  change.moveStartToStartOfNode(change.value.document).moveToStart()\n}\n\nCommands.moveToStartOfInline = change => {\n  change.moveStartToStartOfInline().moveToStart()\n}\n\nCommands.moveToStartOfNextBlock = change => {\n  change.moveEndToStartOfNextBlock().moveToEnd()\n}\n\nCommands.moveToStartOfNextInline = change => {\n  change.moveEndToStartOfNextInline().moveToEnd()\n}\n\nCommands.moveToStartOfNextText = change => {\n  change.moveEndToStartOfNextText().moveToEnd()\n}\n\nCommands.moveToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveToStartOfNode', ...args)\n}\n\nCommands.moveToStartOfPreviousBlock = change => {\n  change.moveStartToStartOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToStartOfPreviousInline = change => {\n  change.moveStartToStartOfPreviousInline().moveToStart()\n}\n\nCommands.moveToStartOfPreviousText = change => {\n  change.moveStartToStartOfPreviousText().moveToStart()\n}\n\nCommands.moveToStartOfText = change => {\n  change.moveStartToStartOfText().moveToStart()\n}\n\nCommands.select = (change, properties, options = {}) => {\n  properties = Selection.createProperties(properties)\n  const { snapshot = false } = options\n  const { value } = change\n  const { document, selection } = value\n  const props = {}\n  let next = selection.setProperties(properties)\n  next = document.resolveSelection(next)\n\n  // Re-compute the properties, to ensure that we get their normalized values.\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      props[k] = properties[k]\n    }\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  if (selection.marks && !props.marks && (props.anchor || props.focus)) {\n    props.marks = null\n  }\n\n  // If there are no new properties to set, abort to avoid extra operations.\n  if (Object.keys(props).length === 0) {\n    return\n  }\n\n  change.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: props,\n      selection: selection.toJSON(),\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\nCommands.setAnchor = (change, ...args) => {\n  change.call(proxy, 'setAnchor', ...args)\n}\n\nCommands.setEnd = (change, ...args) => {\n  change.call(proxy, 'setEnd', ...args)\n}\n\nCommands.setFocus = (change, ...args) => {\n  change.call(proxy, 'setFocus', ...args)\n}\n\nCommands.setStart = (change, ...args) => {\n  change.call(proxy, 'setStart', ...args)\n}\n\nCommands.snapshotSelection = change => {\n  change.withoutMerging(() => {\n    change.select(change.value.selection, { snapshot: true })\n  })\n}\n\n/**\n * Helpers.\n */\n\nfunction proxy(change, method, ...args) {\n  const range = change.value.selection[method](...args)\n  change.select(range)\n}\n\nfunction pointEdgeObject(change, point, edge, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object == 'text' ? 'getNode' : `getClosest${Object}`\n  const { value } = change\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  change[method](node)\n}\n\nfunction pointEdgeSideObject(change, point, edge, side, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Side = side.slice(0, 1).toUpperCase() + side.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object == 'text' ? 'getNode' : `getClosest${Object}`\n  const getDirectionNode = `get${Side}${Object}`\n  const { value } = change\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  const target = document[getDirectionNode](node.key)\n  if (!target) return\n  change[method](target)\n}\n\nfunction pointBackward(change, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointForward(change, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { editor, value } = change\n  const { document, selection } = value\n  const p = selection[point]\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset - n >= 0) {\n    const range = selection[`move${Point}Backward`](n)\n    change.select(range)\n    return\n  }\n\n  const previous = document.getPreviousText(p.path)\n  if (!previous) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(previous.key)\n  const isPreviousInVoid =\n    previous && document.hasVoidParent(previous.key, editor)\n  change[`move${Point}ToEndOfNode`](previous)\n\n  // when is this called?\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    const range = change.value.selection[`move${Point}Backward`](n)\n    change.select(range)\n  }\n}\n\nfunction pointForward(change, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointBackward(change, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { editor, value } = change\n  const { document, selection } = value\n  const p = selection[point]\n  const text = document.getNode(p.path)\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    const range = selection[`move${Point}Forward`](n)\n    change.select(range)\n    return\n  }\n\n  const next = document.getNextText(p.path)\n  if (!next) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(next.key)\n  const isNextInVoid = document.hasVoidParent(next.key, editor)\n  change[`move${Point}ToStartOfNode`](next)\n\n  // when is this called?\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    const range = change.value.selection[`move${Point}Forward`](n)\n    change.select(range)\n  }\n}\n\nfunction pointWordBackward(change, pointName) {\n  const { value } = change\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetBackward(text, o)\n  change.call(pointBackward, pointName, n > 0 ? n : 1)\n}\n\nfunction pointWordForward(change, pointName) {\n  const { value } = change\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetForward(text, o)\n  change.call(pointForward, pointName, n > 0 ? n : 1)\n}\n\nexport default Commands\n","import Value from '../models/value'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n */\n\nCommands.setValue = (change, properties) => {\n  properties = Value.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation({\n    type: 'set_value',\n    properties,\n    value,\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","/**\n * A plugin that adds a set of queries to the editor.\n *\n * @param {Object} queries\n * @return {Object}\n */\n\nfunction QueriesPlugin(queries = {}) {\n  /**\n   * On construct, register all the queries.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const query in queries) {\n      editor.registerQuery(query)\n    }\n\n    return next()\n  }\n\n  /**\n   * On query, if it exists in our list of queries, call it.\n   *\n   * @param {Object} query\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onQuery(query, editor, next) {\n    const { type, args } = query\n    const fn = queries[type]\n    if (!fn) return next()\n    const ret = fn(editor, ...args)\n    return ret === undefined ? next() : ret\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onConstruct,\n    onQuery,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default QueriesPlugin\n","/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nclass SlateError extends Error {\n  constructor(code, attrs = {}) {\n    super(code)\n    this.code = code\n\n    for (const key in attrs) {\n      this[key] = attrs[key]\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {SlateError}\n */\n\nexport default SlateError\n","import SlateError from '../utils/slate-error'\nimport Queries from './queries'\n\n/**\n * Create a plugin from a `schema` definition.\n *\n * @param {Object} schema\n * @return {Object}\n */\n\nfunction SchemaPlugin(schema) {\n  const { rules, document, blocks, inlines, marks } = schema\n  let schemaRules = []\n\n  if (rules) {\n    schemaRules = schemaRules.concat(rules)\n  }\n\n  if (document) {\n    schemaRules.push({\n      match: [{ object: 'document' }],\n      ...document,\n    })\n  }\n\n  if (blocks) {\n    for (const key in blocks) {\n      schemaRules.push({\n        match: [{ object: 'block', type: key }],\n        ...blocks[key],\n      })\n    }\n  }\n\n  if (inlines) {\n    for (const key in inlines) {\n      schemaRules.push({\n        match: [{ object: 'inline', type: key }],\n        ...inlines[key],\n      })\n    }\n  }\n\n  if (marks) {\n    for (const key in marks) {\n      schemaRules.push({\n        match: [{ object: 'mark', type: key }],\n        ...marks[key],\n      })\n    }\n  }\n\n  /**\n   * Check if a `mark` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Mark} mark\n   * @return {Boolean}\n   */\n\n  function isAtomic(editor, mark) {\n    const rule = schemaRules.find(\n      r => 'isAtomic' in r && testRules(mark, r.match)\n    )\n\n    return rule && rule.isAtomic\n  }\n\n  /**\n   * Check if a `node` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isVoid(editor, node) {\n    const rule = schemaRules.find(\n      r => 'isVoid' in r && testRules(node, r.match)\n    )\n\n    return rule && rule.isVoid\n  }\n\n  /**\n   * Normalize a `node` with the schema rules, returning a function that will\n   * fix the invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @param {Function} next\n   * @return {Function|Void}\n   */\n\n  function normalizeNode(node, next) {\n    const error = validateNode(node, () => {})\n    if (!error) return next()\n\n    return change => {\n      const { rule } = error\n      const { size } = change.operations\n\n      // First run the user-provided `normalize` function if one exists...\n      if (rule.normalize) {\n        rule.normalize(change, error)\n      }\n\n      // If the `normalize` function did not add any operations to the change\n      // object, it can't have normalized, so run the default one.\n      if (change.operations.size === size) {\n        defaultNormalize(change, error)\n      }\n    }\n  }\n\n  /**\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\n   * invalid.\n   *\n   * @param {Node} node\n   * @param {Function} next\n   * @return {Error|Void}\n   */\n\n  function validateNode(node, next) {\n    const matches = schemaRules.filter(r => testRules(node, r.match))\n    const failure = validateRules(node, matches, schemaRules, { every: true })\n    if (!failure) return next()\n    const error = new SlateError(failure.code, failure)\n    return error\n  }\n\n  /**\n   * On schema-related queries, respond if we can.\n   *\n   * @param {Object} query\n   * @param {Function} next\n   */\n\n  const queries = Queries({ isAtomic, isVoid })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Object}\n   */\n\n  return [{ normalizeNode, validateNode }, queries]\n}\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Change} change\n * @param {SlateError} error\n */\n\nfunction defaultNormalize(change, error) {\n  const { code, node, child, next, previous, key, mark } = error\n\n  switch (code) {\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid': {\n      return child.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? change.removeNodeByKey(node.key)\n        : change.removeNodeByKey(child.key)\n    }\n\n    case 'previous_sibling_object_invalid':\n    case 'previous_sibling_type_invalid': {\n      return previous.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? change.removeNodeByKey(node.key)\n        : change.removeNodeByKey(previous.key)\n    }\n\n    case 'next_sibling_object_invalid':\n    case 'next_sibling_type_invalid': {\n      return next.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? change.removeNodeByKey(node.key)\n        : change.removeNodeByKey(next.key)\n    }\n\n    case 'child_required':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid': {\n      return node.object === 'document'\n        ? node.nodes.forEach(n => change.removeNodeByKey(n.key))\n        : change.removeNodeByKey(node.key)\n    }\n\n    case 'node_data_invalid': {\n      return node.data.get(key) === undefined && node.object !== 'document'\n        ? change.removeNodeByKey(node.key)\n        : change.setNodeByKey(node.key, { data: node.data.delete(key) })\n    }\n\n    case 'node_mark_invalid': {\n      return node\n        .getTexts()\n        .forEach(t => change.removeMarkByKey(t.key, 0, t.text.length, mark))\n    }\n\n    default: {\n      return change.removeNodeByKey(node.key)\n    }\n  }\n}\n\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(object, rules) {\n  const error = validateRules(object, rules)\n  return !error\n}\n\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(object, rule, rules, options = {}) {\n  const { every = false } = options\n\n  if (Array.isArray(rule)) {\n    const array = rule.length ? rule : [{}]\n    let first\n\n    for (const r of array) {\n      const error = validateRules(object, r, rules)\n      first = first || error\n      if (every && error) return error\n      if (!every && !error) return\n    }\n\n    return first\n  }\n\n  const error =\n    validateObject(object, rule) ||\n    validateType(object, rule) ||\n    validateData(object, rule) ||\n    validateMarks(object, rule) ||\n    validateText(object, rule) ||\n    validateFirst(object, rule) ||\n    validateLast(object, rule) ||\n    validateNodes(object, rule, rules)\n\n  return error\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return\n  if (rule.object === node.object) return\n  if (typeof rule.object === 'function' && rule.object(node.object)) return\n  return fail('node_object_invalid', { rule, node })\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return\n  if (rule.type === node.type) return\n  if (typeof rule.type === 'function' && rule.type(node.type)) return\n  return fail('node_type_invalid', { rule, node })\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return\n  if (node.data == null) return\n\n  if (typeof rule.data === 'function') {\n    if (rule.data(node.data)) return\n    return fail('node_data_invalid', { rule, node })\n  }\n\n  for (const key in rule.data) {\n    const fn = rule.data[key]\n    const value = node.data && node.data.get(key)\n    const valid = typeof fn === 'function' ? fn(value) : fn === value\n    if (valid) continue\n    return fail('node_data_invalid', { rule, node, key, value })\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return\n  const marks = node.getMarks().toArray()\n\n  for (const mark of marks) {\n    const valid = rule.marks.some(\n      def =>\n        typeof def.type === 'function'\n          ? def.type(mark.type)\n          : def.type === mark.type\n    )\n    if (valid) continue\n    return fail('node_mark_invalid', { rule, node, mark })\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return\n  const { text } = node\n  const valid =\n    typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text)\n  if (valid) return\n  return fail('node_text_invalid', { rule, node, text })\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return\n  const first = node.nodes.first()\n  if (!first) return\n  const error = validateRules(first, rule.first)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = first\n  error.code = error.code.replace('node_', 'first_child_')\n  return error\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return\n  const last = node.nodes.last()\n  if (!last) return\n  const error = validateRules(last, rule.last)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = last\n  error.code = error.code.replace('node_', 'last_child_')\n  return error\n}\n\nfunction validateNodes(node, rule, rules = []) {\n  if (node.nodes == null) return\n\n  const children = node.nodes.toArray()\n  const defs = rule.nodes != null ? rule.nodes.slice() : []\n  let offset\n  let min\n  let index\n  let def\n  let max\n  let child\n  let previous\n  let next\n\n  function nextDef() {\n    offset = offset == null ? null : 0\n    def = defs.shift()\n    min = def && def.min\n    max = def && def.max\n    return !!def\n  }\n\n  function nextChild() {\n    index = index == null ? 0 : index + 1\n    offset = offset == null ? 0 : offset + 1\n    previous = child\n    child = children[index]\n    next = children[index + 1]\n    if (max != null && offset == max) nextDef()\n    return !!child\n  }\n\n  function rewind() {\n    offset -= 1\n    index -= 1\n  }\n\n  if (rule.nodes != null) {\n    nextDef()\n  }\n\n  while (nextChild()) {\n    const err =\n      validateParent(node, child, rules) ||\n      validatePrevious(node, child, previous, index, rules) ||\n      validateNext(node, child, next, index, rules)\n\n    if (err) return err\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', { rule, node, child, index })\n      }\n\n      if (def.match) {\n        const error = validateRules(child, def.match)\n\n        if (error && offset >= min && nextDef()) {\n          rewind()\n          continue\n        }\n\n        if (error) {\n          error.rule = rule\n          error.node = node\n          error.child = child\n          error.index = index\n          error.code = error.code.replace('node_', 'child_')\n          return error\n        }\n      }\n    }\n  }\n\n  if (rule.nodes != null) {\n    while (min != null) {\n      if (offset < min) {\n        return fail('child_required', { rule, node, index })\n      }\n\n      nextDef()\n    }\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  for (const rule of rules) {\n    if (rule.parent == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(node, rule.parent)\n    if (!error) continue\n\n    error.rule = rule\n    error.parent = node\n    error.node = child\n    error.code = error.code.replace('node_', 'parent_')\n    return error\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return\n\n  for (const rule of rules) {\n    if (rule.previous == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(previous, rule.previous)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.previous = previous\n    error.code = error.code.replace('node_', 'previous_sibling_')\n    return error\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return\n\n  for (const rule of rules) {\n    if (rule.next == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(next, rule.next)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.next = next\n    error.code = error.code.replace('node_', 'next_sibling_')\n    return error\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return { code, ...attrs }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default SchemaPlugin\n","import AtCurrentRange from '../commands/at-current-range'\nimport AtRange from '../commands/at-range'\nimport ByPath from '../commands/by-path'\nimport Commands from './commands'\nimport OnHistory from '../commands/on-history'\nimport OnSelection from '../commands/on-selection'\nimport OnValue from '../commands/on-value'\nimport Queries from './queries'\nimport Schema from './schema'\nimport Text from '../models/text'\n\n/**\n * A plugin that defines the core Slate logic.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction CorePlugin(options = {}) {\n  const { plugins = [] } = options\n\n  /**\n   * The core Slate commands.\n   *\n   * @type {Object}\n   */\n\n  const commands = Commands({\n    ...AtCurrentRange,\n    ...AtRange,\n    ...ByPath,\n    ...OnHistory,\n    ...OnSelection,\n    ...OnValue,\n  })\n\n  /**\n   * The core Slate queries.\n   *\n   * @type {Object}\n   */\n\n  const queries = Queries({\n    isAtomic: () => false,\n    isVoid: () => false,\n  })\n\n  /**\n   * The core Slate schema.\n   *\n   * @type {Object}\n   */\n\n  const schema = Schema({\n    rules: [\n      // Only allow block nodes in documents.\n      {\n        match: { object: 'document' },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n\n      // Only allow block nodes or inline and text nodes in blocks.\n      {\n        match: {\n          object: 'block',\n          first: { object: 'block' },\n        },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n      {\n        match: {\n          object: 'block',\n          first: [{ object: 'inline' }, { object: 'text' }],\n        },\n        nodes: [\n          {\n            match: [{ object: 'inline' }, { object: 'text' }],\n          },\n        ],\n      },\n\n      // Only allow inline and text nodes in inlines.\n      {\n        match: { object: 'inline' },\n        nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }],\n      },\n\n      // Ensure that block and inline nodes have at least one text child.\n      {\n        match: [{ object: 'block' }, { object: 'inline' }],\n        nodes: [{ min: 1 }],\n        normalize: (change, error) => {\n          const { code, node } = error\n\n          if (code === 'child_required') {\n            change.insertNodeByKey(node.key, 0, Text.create())\n          }\n        },\n      },\n\n      // Ensure that inline nodes are surrounded by text nodes.\n      {\n        match: { object: 'block' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        normalize: (change, error) => {\n          const { code, node } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else {\n            return\n          }\n\n          change.insertNodeByKey(node.key, i, text)\n        },\n      },\n      {\n        match: { object: 'inline' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        previous: [{ object: 'block' }, { object: 'text' }],\n        next: [{ object: 'block' }, { object: 'text' }],\n        normalize: (change, error) => {\n          const { code, node, index } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else if (code === 'previous_sibling_object_invalid') {\n            i = index\n          } else if (code === 'next_sibling_object_invalid') {\n            i = index + 1\n          } else {\n            return\n          }\n\n          change.insertNodeByKey(node.key, i, text)\n        },\n      },\n\n      // Merge adjacent text nodes.\n      {\n        match: { object: 'text' },\n        next: [{ object: 'block' }, { object: 'inline' }],\n        normalize: (change, error) => {\n          const { code, next } = error\n\n          if (code === 'next_sibling_object_invalid') {\n            change.mergeNodeByKey(next.key)\n          }\n        },\n      },\n    ],\n  })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  return [schema, ...plugins, commands, queries]\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CorePlugin\n","import Debug from 'debug'\nimport invariant from 'tiny-invariant'\n\nimport AbstractChange from './change'\nimport CorePlugin from '../plugins/core'\nimport CommandsPlugin from '../plugins/commands'\nimport QueriesPlugin from '../plugins/queries'\nimport SchemaPlugin from '../plugins/schema'\nimport Value from '../models/value'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Editor}\n */\n\nclass Editor {\n  /**\n   * Create a new `Editor` with `attrs`.\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n\n  constructor(attrs = {}, options = {}) {\n    const { editor = this } = options\n    const {\n      onChange = () => {},\n      plugins = [],\n      readOnly = false,\n      value = Value.create(),\n    } = attrs\n\n    this.Change = class Change extends AbstractChange {}\n    this.editor = editor\n    this.middleware = {}\n    this.onChange = onChange\n    this.readOnly = null\n    this.value = null\n\n    this.tmp = {\n      change: null,\n      isChanging: false,\n    }\n\n    const core = CorePlugin({ plugins })\n    registerPlugin(this, core)\n\n    this.run('onConstruct', this)\n\n    this.setReadOnly(readOnly)\n    this.setValue(value, options)\n  }\n\n  /**\n   * Perform a change on the editor, passing `...args` to `change.call`.\n   *\n   * @param {Any} ...args\n   */\n\n  change(...args) {\n    const { Change, editor, value } = this\n    const { isChanging } = this.tmp\n    const change = isChanging ? this.tmp.change : new Change({ value, editor })\n\n    try {\n      this.tmp.change = change\n      this.tmp.isChanging = true\n      change.call(...args)\n    } catch (error) {\n      throw error\n    } finally {\n      this.tmp.isChanging = isChanging\n    }\n\n    // If this isn't the top-most change function, exit to let it finish.\n    if (isChanging === true) {\n      return\n    }\n\n    // If the change doesn't define any operations to apply, abort.\n    if (change.operations.size === 0) {\n      return\n    }\n\n    this.run('onChange', change)\n\n    // Call the provided `onChange` handler.\n    this.value = change.value\n    this.onChange(change)\n  }\n\n  /**\n   * Trigger a `command` with `...args`.\n   *\n   * @param {String} command\n   * @param {Any} ...args\n   */\n\n  command(command, ...args) {\n    debug('command', { command, args })\n\n    this.change(change => {\n      const obj = { type: command, args }\n      this.run('onCommand', obj, change)\n    })\n  }\n\n  /**\n   * Process an `event` by running it through the stack.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  event(handler, event) {\n    debug('event', { handler, event })\n\n    this.change(change => {\n      this.run(handler, event, change)\n    })\n  }\n\n  /**\n   * Ask a `query` with `...args`.\n   *\n   * @param {String} query\n   * @param {Any} ...args\n   */\n\n  query(query, ...args) {\n    debug('query', { query, args })\n\n    const { editor } = this\n    const obj = { type: query, args }\n    return this.run('onQuery', obj, editor)\n  }\n\n  /**\n   * Register a `command` with the editor.\n   *\n   * @param {String} command\n   */\n\n  registerCommand(command) {\n    const { Change } = this\n    if (Change.prototype[command]) return\n\n    Change.prototype[command] = function(...args) {\n      const change = this.command(command, ...args)\n      return change\n    }\n  }\n\n  /**\n   * Register a `query` with the editor.\n   *\n   * @param {String} query\n   */\n\n  registerQuery(query) {\n    const { Change } = this\n    if (Change.prototype[query]) return\n\n    Change.prototype[query] = function(...args) {\n      const ret = this.query(query, ...args)\n      return ret\n    }\n  }\n\n  /**\n   * Run through the middleware stack by `key` with `args`.\n   *\n   * @param {String} key\n   * @param {Any} ...args\n   * @return {Any}\n   */\n\n  run(key, ...args) {\n    const middleware = this.middleware[key] || []\n    let i = 0\n\n    function next(...overrides) {\n      const fn = middleware[i++]\n      if (!fn) return\n\n      if (overrides.length) {\n        args = overrides\n      }\n\n      const ret = fn(...args, next)\n      return ret\n    }\n\n    Object.defineProperty(next, 'change', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42.0, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'onChange', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42.0, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'props', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42.0, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'schema', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42.0, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'stack', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42.0, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    return next()\n  }\n\n  /**\n   * Set the `readOnly` flag.\n   *\n   * @param {Boolean} readOnly\n   * @return {Editor}\n   */\n\n  setReadOnly(readOnly) {\n    this.readOnly = readOnly\n    return this\n  }\n\n  /**\n   * Set the editor's `value`.\n   *\n   * @param {Value} value\n   * @param {Options} options\n   * @return {Editor}\n   */\n\n  setValue(value, options = {}) {\n    const { normalize = value !== this.value } = options\n    this.value = value\n\n    if (normalize) {\n      this.change(change => change.normalize())\n    }\n\n    return this\n  }\n}\n\n/**\n * Register a `plugin` with the editor.\n *\n * @param {Editor} editor\n * @param {Object|Array} plugin\n */\n\nfunction registerPlugin(editor, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(p => registerPlugin(editor, p))\n    return\n  }\n\n  const { commands, queries, schema, ...rest } = plugin\n\n  if (commands) {\n    const commandsPlugin = CommandsPlugin(commands)\n    registerPlugin(editor, commandsPlugin)\n  }\n\n  if (queries) {\n    const queriesPlugin = QueriesPlugin(queries)\n    registerPlugin(editor, queriesPlugin)\n  }\n\n  if (schema) {\n    const schemaPlugin = SchemaPlugin(schema)\n    registerPlugin(editor, schemaPlugin)\n  }\n\n  for (const key in rest) {\n    const fn = rest[key]\n    const middleware = (editor.middleware[key] = editor.middleware[key] || [])\n    middleware.push(fn)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Editor}\n */\n\nexport default Editor\n","/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Interface\n * @param {Class} Class\n */\n\nexport default function mixin(Interface, Classes) {\n  for (const Class of Classes) {\n    // Copy static properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface)) {\n      if (Class.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface, name)\n      Object.defineProperty(Class, name, desc)\n    }\n\n    // Copy instance properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface.prototype)) {\n      if (Class.prototype.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface.prototype, name)\n      Object.defineProperty(Class.prototype, name, desc)\n    }\n  }\n}\n","import Block from '../models/block'\nimport Change from '../controllers/change'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Editor from '../controllers/editor'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\nimport isObject, { TYPES } from '../utils/is-object'\nimport mixin from '../utils/mixin'\n\n/**\n * A factory for the interface that all Slate objects implement.\n *\n * @type {Function}\n */\n\nfunction create(type) {\n  const TYPE = TYPES[type]\n  const camel = `${type.charAt(0).toUpperCase()}${type.slice(1)}`\n  const is = `is${camel}`\n\n  class ObjectInterface {\n    /**\n     * Return the type of the object.\n     *\n     * @return {String}\n     */\n\n    get object() {\n      return type\n    }\n  }\n\n  ObjectInterface[is] = isObject.bind(null, type)\n  ObjectInterface.prototype[TYPE] = true\n  return ObjectInterface\n}\n\n/**\n * Mix in the object interfaces.\n */\n\nmixin(create('block'), [Block])\nmixin(create('change'), [Change])\nmixin(create('decoration'), [Decoration])\nmixin(create('document'), [Document])\nmixin(create('editor'), [Editor])\nmixin(create('inline'), [Inline])\nmixin(create('leaf'), [Leaf])\nmixin(create('mark'), [Mark])\nmixin(create('node'), [Node])\nmixin(create('operation'), [Operation])\nmixin(create('point'), [Point])\nmixin(create('range'), [Range])\nmixin(create('selection'), [Selection])\nmixin(create('text'), [Text])\nmixin(create('value'), [Value])\n","import mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\n\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nclass ModelInterface {\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS(...args) {\n    return this.fromJSON(...args)\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(...args) {\n    return this.toJSON(...args)\n  }\n}\n\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\nmixin(ModelInterface, [\n  Block,\n  Decoration,\n  Document,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Selection,\n  Text,\n  Value,\n])\n","import warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Text from '../models/text'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass NodeInterface {\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Get the first text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.find(node => {\n      if (node.object === 'text') return true\n      descendant = node.getFirstText()\n      return !!descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Object}\n   */\n\n  getKeysToPathsTable() {\n    const ret = {\n      [this.key]: [],\n    }\n\n    if (this.nodes) {\n      this.nodes.forEach((node, i) => {\n        const nested = node.getKeysToPathsTable()\n\n        for (const key in nested) {\n          const path = nested[key]\n\n          warning(\n            !(key in ret),\n            `A node with a duplicate key of \"${key}\" was found! Duplicate keys are not allowed, you should use \\`node.regenerateKey\\` before inserting if you are reusing an existing node.`\n          )\n\n          ret[key] = [i, ...path]\n        }\n      })\n    }\n\n    return ret\n  }\n\n  /**\n   * Get the last text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object == 'text') return true\n      descendant = node.getLastText()\n      return descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get a node in the tree, or the node itself.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (this.object === 'text' && path.size) return null\n    const node = path.size ? this.getDescendant(path) : this\n    return node\n  }\n\n  /**\n   * Find the path to a node.\n   *\n   * @param {String|List} key\n   * @return {List}\n   */\n\n  getPath(key) {\n    // Handle the case of passing in a path directly, to match other methods.\n    if (List.isList(key)) return key\n\n    const dict = this.getKeysToPathsTable()\n    const path = dict[key]\n    return path ? List(path) : null\n  }\n\n  /**\n   * Get the concatenated text string of a node.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    const children = this.object === 'text' ? this.leaves : this.nodes\n    const text = children.reduce((memo, c) => memo + c.text, '')\n    return text\n  }\n\n  /**\n   * Check if a node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasNode(path) {\n    const node = this.getNode(path)\n    return !!node\n  }\n\n  /**\n   * Normalize the text node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Function|Void}\n   */\n\n  normalize(editor) {\n    const normalizer = editor.run('normalizeNode', this)\n    return normalizer\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = KeyUtils.create()\n    const node = this.set('key', key)\n    return node\n  }\n\n  /**\n   * Resolve a path from a path list or key string.\n   *\n   * An `index` can be provided, in which case paths created from a key string\n   * will have the index pushed onto them. This is helpful in cases where you\n   * want to accept either a `path` or a `key, index` combination for targeting\n   * a location in the tree that doesn't exist yet, like when inserting.\n   *\n   * @param {List|String} value\n   * @param {Number} index\n   * @return {List}\n   */\n\n  resolvePath(path, index) {\n    if (typeof path === 'string') {\n      path = this.getPath(path)\n\n      if (index != null) {\n        path = path.concat(index)\n      }\n    } else {\n      path = PathUtils.create(path)\n    }\n\n    return path\n  }\n\n  /**\n   * Validate the node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Error|Void}\n   */\n\n  validate(editor) {\n    const error = editor.run('validateNode', this)\n    return error\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(NodeInterface.prototype, [\n  'getFirstText',\n  'getKeysToPathsTable',\n  'getLastText',\n  'getText',\n  'normalize',\n  'validate',\n])\n\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text])\n","import direction from 'direction'\nimport invariant from 'tiny-invariant'\nimport { List, OrderedSet, Set } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Value from '../models/value'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass ElementInterface {\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  addMark(path, offset, length, mark) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.addMark(offset, length, mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Create a decoration with `properties` relative to the node.\n   *\n   * @param {Object|Decoration} properties\n   * @return {Decoration}\n   */\n\n  createDecoration(properties) {\n    properties = Decoration.createProperties(properties)\n    const decoration = this.resolveDecoration(properties)\n    return decoration\n  }\n\n  /**\n   * Create a point with `properties` relative to the node.\n   *\n   * @param {Object|Point} properties\n   * @return {Range}\n   */\n\n  createPoint(properties) {\n    properties = Point.createProperties(properties)\n    const point = this.resolvePoint(properties)\n    return point\n  }\n\n  /**\n   * Create a range with `properties` relative to the node.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  createRange(properties) {\n    properties = Range.createProperties(properties)\n    const range = this.resolveRange(properties)\n    return range\n  }\n\n  /**\n   * Create a selection with `properties` relative to the node.\n   *\n   * @param {Object|Selection} properties\n   * @return {Selection}\n   */\n\n  createSelection(properties) {\n    properties = Selection.createProperties(properties)\n    const selection = this.resolveSelection(properties)\n    return selection\n  }\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants(iterator) {\n    const matches = []\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) matches.push(node)\n    })\n\n    return List(matches)\n  }\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant(iterator) {\n    let found = null\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) {\n        found = node\n        return false\n      }\n    })\n\n    return found\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant(iterator) {\n    let ret\n\n    this.nodes.forEach((child, i, nodes) => {\n      if (iterator(child, i, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object != 'text') {\n        ret = child.forEachDescendant(iterator)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get a set of the active marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return Set()\n\n    if (range.isCollapsed) {\n      const { start } = range\n      return this.getMarksAtPosition(start.key, start.offset).toSet()\n    }\n\n    const { start, end } = range\n    let startKey = start.key\n    let startOffset = start.offset\n    let endKey = end.key\n    let endOffset = end.offset\n    let startText = this.getDescendant(startKey)\n\n    if (startKey !== endKey) {\n      while (startKey !== endKey && endOffset === 0) {\n        const endText = this.getPreviousText(endKey)\n        endKey = endText.key\n        endOffset = endText.text.length\n      }\n\n      while (startKey !== endKey && startOffset === startText.text.length) {\n        startText = this.getNextText(startKey)\n        startKey = startText.key\n        startOffset = 0\n      }\n    }\n\n    if (startKey === endKey) {\n      return startText.getActiveMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const startMarks = startText.getActiveMarksBetweenOffsets(\n      startOffset,\n      startText.text.length\n    )\n    if (startMarks.size === 0) return Set()\n    const endText = this.getDescendant(endKey)\n    const endMarks = endText.getActiveMarksBetweenOffsets(0, endOffset)\n    let marks = startMarks.intersect(endMarks)\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) return marks\n\n    let text = this.getNextText(startKey)\n\n    while (text.key !== endKey) {\n      if (text.text.length !== 0) {\n        marks = marks.intersect(text.getActiveMarks())\n        if (marks.size === 0) return Set()\n      }\n\n      text = this.getNextText(text.key)\n    }\n    return marks\n  }\n\n  /**\n   * Get a list of the ancestors of a descendant.\n   *\n   * @param {List|String} path\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const ancestors = []\n\n    path.forEach((p, i) => {\n      const current = path.slice(0, i)\n      const parent = this.getNode(current)\n      ancestors.push(parent)\n    })\n\n    return List(ancestors)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const array = this.getBlocksAsArray()\n    return List(array)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray() {\n    return this.nodes.reduce((array, child) => {\n      if (child.object != 'block') return array\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray())\n      array.push(child)\n      return array\n    }, [])\n  }\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange(range) {\n    const array = this.getBlocksAtRangeAsArray(range)\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return List(OrderedSet(array))\n  }\n\n  /**\n   * Get the leaf block descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const { start, end } = range\n    const startBlock = this.getClosestBlock(start.key)\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (start.key === end.key) return [startBlock]\n\n    const endBlock = this.getClosestBlock(end.key)\n    const blocks = this.getBlocksAsArray()\n    const startIndex = blocks.indexOf(startBlock)\n    const endIndex = blocks.indexOf(endBlock)\n    return blocks.slice(startIndex, endIndex + 1)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const array = this.getBlocksByTypeAsArray(type)\n    return List(array)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      if (node.object != 'block') {\n        return array\n      } else if (node.isLeafBlock() && node.type == type) {\n        array.push(node)\n        return array\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Get a child node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getChild(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    const child = path.size === 1 ? this.nodes.get(path.first()) : null\n    return child\n  }\n\n  /**\n   * Get closest parent of node that matches an `iterator`.\n   *\n   * @param {List|String} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const closest = ancestors.findLast((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return closest || null\n  }\n\n  /**\n   * Get the closest block parent of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(path) {\n    const closest = this.getClosest(path, n => n.object === 'block')\n    return closest\n  }\n\n  /**\n   * Get the closest inline parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestInline(path) {\n    const closest = this.getClosest(path, n => n.object === 'inline')\n    return closest\n  }\n\n  /**\n   * Get the closest void parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.'\n    )\n\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const ancestor = ancestors.findLast(a => editor.query('isVoid', a))\n    return ancestor\n  }\n\n  /**\n   * Get the common ancestor of nodes `a` and `b`.\n   *\n   * @param {List} a\n   * @param {List} b\n   * @return {Node}\n   */\n\n  getCommonAncestor(a, b) {\n    a = this.resolvePath(a)\n    b = this.resolvePath(b)\n    if (!a || !b) return null\n\n    const path = PathUtils.relate(a, b)\n    const node = this.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the decorations for the node from an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {List}\n   */\n\n  getDecorations(editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.getDecorations` method takes an `editor` instead of a `value`.'\n    )\n\n    const array = editor.run('decorateNode', this) || []\n    const decorations = Decoration.createList(array)\n    return decorations\n  }\n\n  /**\n   * Get the depth of a descendant, with optional `startAt`.\n   *\n   * @param {List|String} path\n   * @param {Number} startAt\n   * @return {Number|Null}\n   */\n\n  getDepth(path, startAt = 1) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const node = this.getNode(path)\n    const depth = node ? path.size - 1 + startAt : null\n    return depth\n  }\n\n  /**\n   * Get a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getDescendant(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.getIn(deep)\n    return ret\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return Document.create()\n    }\n\n    const { start, end } = range\n    let node = this\n    let targetPath = end.path\n    let targetPosition = end.offset\n    let mode = 'end'\n\n    while (targetPath.size) {\n      const index = targetPath.last()\n      node = node.splitNode(targetPath, targetPosition)\n      targetPosition = index + 1\n      targetPath = PathUtils.lift(targetPath)\n\n      if (!targetPath.size && mode === 'end') {\n        targetPath = start.path\n        targetPosition = start.offset\n        mode = 'start'\n      }\n    }\n\n    const startIndex = start.path.first() + 1\n    const endIndex = end.path.first() + 2\n    const nodes = node.nodes.slice(startIndex, endIndex)\n    const fragment = Document.create({ nodes })\n    return fragment\n  }\n\n  /**\n   * Get the furthest parent of a node that matches an `iterator`.\n   *\n   * @param {Path} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors.find((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return furthest || null\n  }\n\n  /**\n   * Get the furthest ancestor of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    const furthest = path.size ? this.nodes.get(path.first()) : null\n    return furthest\n  }\n\n  /**\n   * Get the furthest block parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'block')\n    return furthest\n  }\n\n  /**\n   * Get the furthest inline parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'inline')\n    return furthest\n  }\n\n  /**\n   * Get the furthest ancestor of a node that has only one child.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor(path) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors\n      .rest()\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      .last()\n\n    return furthest || null\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const array = this.getInlinesAsArray()\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray() {\n    let array = []\n\n    this.nodes.forEach(child => {\n      if (child.object == 'text') return\n\n      if (child.isLeafInline()) {\n        array.push(child)\n      } else {\n        array = array.concat(child.getInlinesAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange(range) {\n    const array = this.getInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    const list = List(OrderedSet(array))\n    return list\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const array = this.getInlinesByTypeAsArray(type)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray(type) {\n    const array = this.nodes.reduce((inlines, node) => {\n      if (node.object == 'text') {\n        return inlines\n      } else if (node.isLeafInline() && node.type == type) {\n        inlines.push(node)\n        return inlines\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type))\n      }\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start } = range\n\n    if (range.isUnset) {\n      return Set()\n    }\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(start.key, start.offset)\n    }\n\n    const text = this.getDescendant(start.key)\n    const marks = text.getMarksAtIndex(start.offset + 1)\n    return marks\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return Set(array)\n  }\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    const result = []\n\n    this.nodes.forEach(node => {\n      result.push(node.getMarksAsArray())\n    })\n\n    // PERF: use only one concat rather than multiple for speed.\n    const array = [].concat(...result)\n    return array\n  }\n\n  /**\n   * Get a set of marks in a `position`, the equivalent of a collapsed range\n   *\n   * @param {string} key\n   * @param {number} offset\n   * @return {Set}\n   */\n\n  getMarksAtPosition(key, offset) {\n    const text = this.getDescendant(key)\n    const currentMarks = text.getMarksAtIndex(offset)\n    if (offset !== 0) return currentMarks\n    const closestBlock = this.getClosestBlock(key)\n\n    if (closestBlock.text === '') {\n      // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n      return currentMarks\n    }\n\n    const previous = this.getPreviousText(key)\n    if (!previous) return Set()\n\n    if (closestBlock.hasDescendant(previous.key)) {\n      return previous.getMarksAtIndex(previous.text.length)\n    }\n\n    return currentMarks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    const marks = Set(this.getOrderedMarksAtRange(range))\n    return marks\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return Set(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray(type) {\n    const array = this.nodes.reduce((memo, node) => {\n      return node.object == 'text'\n        ? memo.concat(node.getMarksAsArray().filter(m => m.type == type))\n        : memo.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock(key) {\n    const child = this.assertDescendant(key)\n    let last\n\n    if (child.object == 'block') {\n      last = child.getLastText()\n    } else {\n      const block = this.getClosestBlock(key)\n      last = block.getLastText()\n    }\n\n    const next = this.getNextText(last.key)\n    if (!next) return null\n\n    const closest = this.getClosestBlock(next.key)\n    return closest\n  }\n\n  /**\n   * Get the next node in the tree from a node.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the next ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      const target = PathUtils.increment(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the next sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const p = PathUtils.increment(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const next = this.getNextNode(path)\n    if (!next) return null\n    const text = next.getFirstText()\n    return text\n  }\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset(key) {\n    this.assertDescendant(key)\n\n    // Calculate the offset of the nodes before the highest child.\n    const child = this.getFurthestAncestor(key)\n    const offset = this.nodes\n      .takeUntil(n => n == child)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    const ret = this.hasChild(key) ? offset : offset + child.getOffset(key)\n    return ret\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { start } = range\n    const offset = this.getOffset(start.key) + start.offset\n    return offset\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks() {\n    const array = this.getMarksAsArray()\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start, end } = range\n\n    if (range.isUnset) {\n      return OrderedSet()\n    }\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(start.key, start.offset)\n    }\n\n    const marks = this.getOrderedMarksBetweenPositions(\n      start.key,\n      start.offset,\n      end.key,\n      end.offset\n    )\n\n    return marks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   * PERF: arguments use key and offset for utilizing cache\n   *\n   * @param {string} startKey\n   * @param {number} startOffset\n   * @param {string} endKey\n   * @param {number} endOffset\n   * @returns {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset) {\n    if (startKey === endKey) {\n      const startText = this.getDescendant(startKey)\n      return startText.getMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const texts = this.getTextsBetweenPositionsAsArray(startKey, endKey)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        if (text.key === startKey) {\n          result.union(\n            text.getMarksBetweenOffsets(startOffset, text.text.length)\n          )\n        } else if (text.key === endKey) {\n          result.union(text.getMarksBetweenOffsets(0, endOffset))\n        } else {\n          result.union(text.getMarks())\n        }\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get the parent of a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getParent(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const parentPath = PathUtils.lift(path)\n    const parent = this.getNode(parentPath)\n    return parent\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(key) {\n    const child = this.assertDescendant(key)\n    let first\n\n    if (child.object == 'block') {\n      first = child.getFirstText()\n    } else {\n      const block = this.getClosestBlock(key)\n      first = block.getFirstText()\n    }\n\n    const previous = this.getPreviousText(first.key)\n    if (!previous) return null\n\n    const closest = this.getClosestBlock(previous.key)\n    return closest\n  }\n\n  /**\n   * Get the previous node from a node in the tree.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      if (p.last() === 0) continue\n\n      const target = PathUtils.decrement(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the previous sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    if (path.last() === 0) return null\n    const p = PathUtils.decrement(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const previous = this.getPreviousNode(path)\n    if (!previous) return null\n    const text = previous.getLastText()\n    return text\n  }\n\n  /**\n   * Get the indexes of the selection for a `range`, given an extra flag for\n   * whether the node `isSelected`, to determine whether not finding matches\n   * means everything is selected or nothing is.\n   *\n   * @param {Range} range\n   * @param {Boolean} isSelected\n   * @return {Object|Null}\n   */\n\n  getSelectionIndexes(range, isSelected = true) {\n    const { start, end } = range\n\n    // PERF: if we're not selected, we can exit early.\n    if (!isSelected) {\n      return null\n    }\n\n    // if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (start.key == end.key) {\n      const child = this.getFurthestAncestor(start.key)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let startIndex = null\n    let endIndex = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object == 'text') {\n        if (startIndex == null && child.key == start.key) startIndex = i\n        if (endIndex == null && child.key == end.key) endIndex = i + 1\n      } else {\n        if (startIndex == null && child.hasDescendant(start.key)) startIndex = i\n        if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return startIndex == null || endIndex == null\n    })\n\n    if (isSelected && startIndex == null) startIndex = 0\n    if (isSelected && endIndex == null) endIndex = this.nodes.size\n    return startIndex == null ? null : { start: startIndex, end: endIndex }\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset === 0) return this.getFirstText()\n    if (offset === this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n    const text = this.getTexts().find((node, i, nodes) => {\n      length += node.text.length\n      return length > offset\n    })\n\n    return text\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = direction(this.text)\n    return dir === 'neutral' ? null : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const array = this.getTextsAsArray()\n    return List(array)\n  }\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray() {\n    let array = []\n\n    this.nodes.forEach(node => {\n      if (node.object == 'text') {\n        array.push(node)\n      } else {\n        array = array.concat(node.getTextsAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return List()\n    const { start, end } = range\n    const list = List(this.getTextsBetweenPositionsAsArray(start.key, end.key))\n\n    return list\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getTextsAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n    const { start, end } = range\n    const texts = this.getTextsBetweenPositionsAsArray(start.key, end.key)\n    return texts\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   * PERF: use key in arguments for cache\n   *\n   * @param {string} startKey\n   * @param {string} endKey\n   * @returns {Array}\n   */\n\n  getTextsBetweenPositionsAsArray(startKey, endKey) {\n    const startText = this.getDescendant(startKey)\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startText]\n\n    const endText = this.getDescendant(endKey)\n    const texts = this.getTextsAsArray()\n    const start = texts.indexOf(startText)\n    const end = texts.indexOf(endText, start)\n    const ret = texts.slice(start, end + 1)\n    return ret\n  }\n\n  /**\n   * Check if the node has block children.\n   *\n   * @return {Boolean}\n   */\n\n  hasBlockChildren() {\n    return !!(this.nodes && this.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasChild(path) {\n    const child = this.getChild(path)\n    return !!child\n  }\n\n  /**\n   * Check if a node has inline children.\n   *\n   * @return {Boolean}\n   */\n\n  hasInlineChildren() {\n    return !!(\n      this.nodes &&\n      this.nodes.find(n => n.object === 'inline' || n.object === 'text')\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasDescendant(path) {\n    const descendant = this.getDescendant(path)\n    return !!descendant\n  }\n\n  /**\n   * Check if a node has a void parent.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Boolean}\n   */\n\n  hasVoidParent(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.'\n    )\n\n    const closest = this.getClosestVoid(path, editor)\n    return !!closest\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(path, node) {\n    path = this.resolvePath(path)\n    const index = path.last()\n    const parentPath = PathUtils.lift(path)\n    let parent = this.assertNode(parentPath)\n    const nodes = parent.nodes.splice(index, 0, node)\n    parent = parent.set('nodes', nodes)\n    const ret = this.replaceNode(parentPath, parent)\n    return ret\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @param {Set} marks\n   * @return {Node}\n   */\n\n  insertText(path, offset, text, marks) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.insertText(offset, text, marks)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    const { object, nodes } = this\n    if (!nodes.size) return true\n    const first = nodes.first()\n    return object === 'block' && first.object !== 'block'\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    const { object, nodes } = this\n    if (!nodes.size) return true\n    const first = nodes.first()\n    return object === 'inline' && first.object !== 'inline'\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = iterator(node, i, this.nodes)\n      if (ret !== node) nodes = nodes.set(ret.key, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object !== 'text') ret = ret.mapDescendants(iterator)\n      ret = iterator(ret, index, this.nodes)\n      if (ret === node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Node}\n   */\n\n  mergeNode(path) {\n    const b = this.assertNode(path)\n    path = this.resolvePath(path)\n\n    if (path.last() === 0) {\n      throw new Error(\n        `Unable to merge node because it has no previous sibling: ${b}`\n      )\n    }\n\n    const withPath = PathUtils.decrement(path)\n    const a = this.assertNode(withPath)\n\n    if (a.object !== b.object) {\n      throw new Error(\n        `Unable to merge two different kinds of nodes: ${a} and ${b}`\n      )\n    }\n\n    const newNode =\n      a.object === 'text'\n        ? a.mergeText(b)\n        : a.set('nodes', a.nodes.concat(b.nodes))\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.removeNode(withPath)\n    ret = ret.insertNode(withPath, newNode)\n    return ret\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Node}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    const node = this.assertNode(path)\n    path = this.resolvePath(path)\n    newPath = this.resolvePath(newPath, newIndex)\n\n    const newParentPath = PathUtils.lift(newPath)\n    this.assertNode(newParentPath)\n\n    const [p, np] = PathUtils.crop(path, newPath)\n    const position = PathUtils.compare(p, np)\n\n    // If the old path ends above and before a node in the new path, then\n    // removing it will alter the target, so we need to adjust the new path.\n    if (path.size < newPath.size && position === -1) {\n      newPath = PathUtils.decrement(newPath, 1, p.size - 1)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(newPath, node)\n    return ret\n  }\n\n  /**\n   * Remove mark from text at `offset` and `length` in node.\n   *\n   * @param {List} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  removeMark(path, offset, length, mark) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.removeMark(offset, length, mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Remove a node.\n   *\n   * @param {List|String} path\n   * @return {Node}\n   */\n\n  removeNode(path) {\n    this.assertDescendant(path)\n    path = this.resolvePath(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.deleteIn(deep)\n    return ret\n  }\n\n  /**\n   * Remove `text` at `offset` in node.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  removeText(path, offset, text) {\n    let node = this.assertDescendant(path)\n    node = node.removeText(offset, text.length)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Replace a `node` in the tree.\n   *\n   * @param {List|Key} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  replaceNode(path, node) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      throw new Error(\n        `Unable to replace a node because it could not be found in the first place: ${path}`\n      )\n    }\n\n    if (!path.size) return node\n    this.assertNode(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.setIn(deep, node)\n    return ret\n  }\n\n  /**\n   * Resolve a `decoration`, relative to the node, ensuring that the keys and\n   * offsets in the decoration exist and that they are synced with the paths.\n   *\n   * @param {Decoration|Object} decoration\n   * @return {Decoration}\n   */\n\n  resolveDecoration(decoration) {\n    decoration = Decoration.create(decoration)\n    decoration = decoration.normalize(this)\n    return decoration\n  }\n\n  /**\n   * Resolve a `point`, relative to the node, ensuring that the keys and\n   * offsets in the point exist and that they are synced with the paths.\n   *\n   * @param {Point|Object} point\n   * @return {Point}\n   */\n\n  resolvePoint(point) {\n    point = Point.create(point)\n    point = point.normalize(this)\n    return point\n  }\n\n  /**\n   * Resolve a `range`, relative to the node, ensuring that the keys and\n   * offsets in the range exist and that they are synced with the paths.\n   *\n   * @param {Range|Object} range\n   * @return {Range}\n   */\n\n  resolveRange(range) {\n    range = Range.create(range)\n    range = range.normalize(this)\n    return range\n  }\n\n  /**\n   * Resolve a `selection`, relative to the node, ensuring that the keys and\n   * offsets in the selection exist and that they are synced with the paths.\n   *\n   * @param {Selection|Object} selection\n   * @return {Selection}\n   */\n\n  resolveSelection(selection) {\n    selection = Selection.create(selection)\n    selection = selection.normalize(this)\n    return selection\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setNode(path, properties) {\n    let node = this.assertNode(path)\n    node = node.merge(properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setMark(path, offset, length, mark, properties) {\n    let node = this.assertNode(path)\n    node = node.updateMark(offset, length, mark, properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  splitNode(path, position, properties) {\n    const child = this.assertNode(path)\n    path = this.resolvePath(path)\n    let a\n    let b\n\n    if (child.object === 'text') {\n      ;[a, b] = child.splitText(position)\n    } else {\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      a = child.set('nodes', befores)\n      b = child.set('nodes', afters).regenerateKey()\n    }\n\n    if (properties && child.object !== 'text') {\n      b = b.merge(properties)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(path, b)\n    ret = ret.insertNode(path, a)\n    return ret\n  }\n}\n\n/**\n * Mix in assertion variants.\n */\n\nconst ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path']\n\nfor (const method of ASSERTS) {\n  ElementInterface.prototype[`assert${method}`] = function(path, ...args) {\n    const ret = this[`get${method}`](path, ...args)\n\n    if (ret == null) {\n      throw new Error(\n        `\\`Node.assert${method}\\` could not find node with path or key: ${path}`\n      )\n    }\n\n    return ret\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(ElementInterface.prototype, [\n  'getBlocksAsArray',\n  'getBlocksAtRangeAsArray',\n  'getBlocksByTypeAsArray',\n  'getDecorations',\n  'getFragmentAtRange',\n  'getInlinesAsArray',\n  'getInlinesAtRangeAsArray',\n  'getInlinesByTypeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getOrderedMarksBetweenPositions',\n  'getInsertMarksAtRange',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getOffset',\n  'getOffsetAtRange',\n  'getPreviousBlock',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPositionsAsArray',\n])\n\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline])\n","import mixin from '../utils/mixin'\nimport Decoration from '../models/decoration'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\n\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nclass RangeInterface {\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchor === this.focus ||\n      (this.anchor.key === this.focus.key &&\n        this.anchor.offset === this.focus.offset)\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is backward.\n   *\n   * @return {Boolean}\n   */\n\n  get isBackward() {\n    const { isUnset, anchor, focus } = this\n\n    if (isUnset) {\n      return null\n    }\n\n    if (anchor.key === focus.key) {\n      return anchor.offset > focus.offset\n    }\n\n    const isBackward = PathUtils.isBefore(focus.path, anchor.path)\n    return isBackward\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    const { isBackward } = this\n    const isForward = isBackward == null ? null : !isBackward\n    return isForward\n  }\n\n  /**\n   * Check whether the range isn't set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    const { anchor, focus } = this\n    const isUnset = anchor.isUnset || focus.isUnset\n    return isUnset\n  }\n\n  /**\n   * Check whether the range is set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return !this.isUnset\n  }\n\n  /**\n   * Get the start point.\n   *\n   * @return {String}\n   */\n\n  get start() {\n    return this.isBackward ? this.focus : this.anchor\n  }\n\n  /**\n   * Get the end point.\n   *\n   * @return {String}\n   */\n\n  get end() {\n    return this.isBackward ? this.anchor : this.focus\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    const range = this.setPoints([this.focus, this.anchor])\n    return range\n  }\n\n  /**\n   * Move the anchor and focus offsets forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveForward(n) {\n    return this.updatePoints(point => point.moveForward(n))\n  }\n\n  /**\n   * Move the anchor and focus offsets backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveBackward(n) {\n    return this.updatePoints(point => point.moveBackward(n))\n  }\n\n  /**\n   * Move the anchor offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorBackward(n) {\n    const range = this.setAnchor(this.anchor.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the anchor offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorForward(n) {\n    const range = this.setAnchor(this.anchor.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(path, offset) {\n    const range = this.setAnchor(this.anchor.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the end offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndBackward(n) {\n    const range = this.setEnd(this.end.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the end offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndForward(n) {\n    const range = this.setEnd(this.end.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's end point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveEndTo(path, offset) {\n    const range = this.setEnd(this.end.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToStartOfNode(node) {\n    const range = this.setEnd(this.end.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToEndOfNode(node) {\n    const range = this.setEnd(this.end.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the focus offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusBackward(n) {\n    const range = this.setFocus(this.focus.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the focus offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusForward(n) {\n    const range = this.setFocus(this.focus.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(path, offset) {\n    const range = this.setFocus(this.focus.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOfNode(node) {\n    const range = this.setFocus(this.focus.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOfNode(node) {\n    const range = this.setFocus(this.focus.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the start offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartBackward(n) {\n    const range = this.setStart(this.start.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the start offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartForward(n) {\n    const range = this.setStart(this.start.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's start point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveStartTo(path, offset) {\n    const range = this.setStart(this.start.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToStartOfNode(node) {\n    const range = this.setStart(this.start.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToEndOfNode(node) {\n    const range = this.setStart(this.start.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move range's points to a new `path` and `offset`.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveTo(path, offset) {\n    return this.updatePoints(point => point.moveTo(path, offset))\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    const range = this.setFocus(this.anchor)\n    return range\n  }\n\n  /**\n   * Move the start point to the end point.\n   *\n   * @return {Range}\n   */\n\n  moveToEnd() {\n    const range = this.setStart(this.end)\n    return range\n  }\n\n  /**\n   * Move the range's points to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToEndOfNode(node) {\n    return this.updatePoints(point => point.moveToEndOfNode(node))\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    const range = this.setAnchor(this.focus)\n    return range\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOfNode(start, end = start) {\n    const range = this.setPoints([\n      this.anchor.moveToStartOfNode(start),\n      this.focus.moveToEndOfNode(end),\n    ])\n\n    return range\n  }\n\n  /**\n   * Move the end point to the start point.\n   *\n   * @return {Range}\n   */\n\n  moveToStart() {\n    const range = this.setEnd(this.start)\n    return range\n  }\n\n  /**\n   * Move the range's points to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToStartOfNode(node) {\n    return this.updatePoints(point => point.moveToStartOfNode(node))\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    return this.updatePoints(point => point.normalize(node))\n  }\n\n  /**\n   * Set the anchor point to a new `anchor`.\n   *\n   * @param {Point} anchor\n   * @return {Range}\n   */\n\n  setAnchor(anchor) {\n    const range = this.set('anchor', anchor)\n    return range\n  }\n\n  /**\n   * Set the end point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setEnd(point) {\n    const range = this.isBackward ? this.setAnchor(point) : this.setFocus(point)\n    return range\n  }\n\n  /**\n   * Set the focus point to a new `focus`.\n   *\n   * @param {Point} focus\n   * @return {Range}\n   */\n\n  setFocus(focus) {\n    const range = this.set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points to new `values`.\n   *\n   * @param {Array<Point>} values\n   * @return {Range}\n   */\n\n  setPoints(values) {\n    const [anchor, focus] = values\n    const range = this.set('anchor', anchor).set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points with `updater` callback\n   *\n   * @param {Function} updater\n   * @return {Range}\n   */\n\n  updatePoints(updater) {\n    let { anchor, focus } = this\n    anchor = updater(anchor)\n    focus = updater(focus)\n    return this.merge({ anchor, focus })\n  }\n\n  /**\n   * Set the start point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setStart(point) {\n    const range = this.isBackward ? this.setFocus(point) : this.setAnchor(point)\n    return range\n  }\n\n  /**\n   * Set new `properties` on the range.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Range.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const range = this.merge(props)\n    return range\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n\n  /**\n   * Return a `Range` instance from any range-like instance.\n   *\n   * @return {Range}\n   */\n\n  toRange() {\n    const properties = Range.createProperties(this)\n    const range = Range.create(properties)\n    return range\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  unset() {\n    const range = this.updatePoints(p => p.unset())\n    return range\n  }\n}\n\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\nmixin(RangeInterface, [Decoration, Range, Selection])\n","import './interfaces/object'\nimport './interfaces/model'\nimport './interfaces/node'\nimport './interfaces/element'\nimport './interfaces/range'\n\nimport Block from './models/block'\nimport Change from './controllers/change'\nimport Data from './models/data'\nimport Decoration from './models/decoration'\nimport Document from './models/document'\nimport Editor from './controllers/editor'\nimport Inline from './models/inline'\nimport KeyUtils from './utils/key-utils'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport PathUtils from './utils/path-utils'\nimport Point from './models/point'\nimport Range from './models/range'\nimport Selection from './models/selection'\nimport Text from './models/text'\nimport TextUtils from './utils/text-utils'\nimport Value from './models/value'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n\nexport default {\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n"],"names":["n","generate","create","key","Error","setGenerator","func","resetGenerator","Data","attrs","Map","isMap","isPlainObject","fromJSON","object","fromJS","DEFAULTS","undefined","Document","options","data","toJSON","nodes","toArray","map","preserveKeys","isDocument","List","isList","Array","isArray","KeyUtils","document","Node","createList","Record","Inline","type","isInline","elements","list","inline","any","every","item","Mark","isMark","Set","isSet","marks","props","mark","Leaf","newMark","equals","has","newMarks","withMutations","remove","add","set","union","offset","string","text","next","slice","m","isLeaf","leaves","size","invalid","result","findLast","leaf","index","firstLeaf","cache","first","unshift","endOffset","left","right","find","startOffset","length","of","take","skip","push","ENABLED","CACHE_KEY","LEAF","UNDEFINED","UNSET","memoize","properties","property","original","args","apply","__cache_key","__cache","__cache_no_args","takesArguments","cachedValue","keys","getIn","value","v","setIn","get","parent","child","resetMemoization","Number","MAX_SAFE_INTEGER","useMemoization","enabled","Text","l","addMarks","newFirst","splitLeaves","before","bundle","middle","after","concat","x","setLeaves","decorations","forEach","start","dec","end","hasStart","hasEnd","addMark","createLeaves","getActiveMarks","leafEnd","leafStart","intersect","toOrderedSet","c","getMarks","array","getMarksAsArray","OrderedSet","prototype","searchLeafAtOffset","delta","beforeText","afterText","nextLeaves","splice","removeMark","getLeaves","r","merge","updateMark","splitted","one","two","regenerateKey","isText","ranges","node","isNode","kind","Block","isBlock","block","compare","path","target","min","i","pv","tv","crop","a","b","ca","cb","decrement","increment","getAncestors","ancestors","newValue","newPath","isAbove","p","t","isAfter","isBefore","isEqual","isOlder","pl","tl","isSibling","butLast","isYounger","lift","max","Math","relate","av","bv","transform","operation","position","pIndex","pEqual","pYounger","pAbove","np","npIndex","npEqual","npYounger","npAbove","paths","Point","point","isUnset","is","PathUtils","range","isAfterPoint","isBeforePoint","last","getLastText","getFirstText","hasNode","moveForward","setOffset","moveBackward","moveTo","getNode","getPath","getTextAtOffset","getOffset","isPoint","Decoration","createProperties","anchor","focus","decoration","isDecoration","Range","isRange","JSON","stringify","TYPES","isObject","Selection","isSelection","selection","isFocused","createSet","Value","insertNode","mapRanges","updatePoints","setPath","assertNode","insertText","newDocument","mergeNode","resolvePath","withPath","moveAnchorTo","moveFocusTo","newIndex","moveNode","prev","getPreviousText","getNextText","removeNode","moveStartTo","unset","moveEndTo","removeText","setNode","setMark","d","resolveDecoration","setProperties","resolveSelection","splitNode","iterator","sel","createSelection","decs","createDecoration","filter","preserveData","preserveDecorations","preserveSelection","getClosestBlock","getClosestInline","getDescendant","getNextBlock","getPreviousBlock","getNextInline","getPreviousInline","getMarksAtRange","getActiveMarksAtRange","getBlocksAtRange","getFragmentAtRange","getInlinesAtRange","getTextsAtRange","isValue","moveToStartOfNode","debug","Debug","applyOperation","op","Operation","setSelection","invertOperation","inverse","inversePath","inverseNewPath","pathLast","newPathLast","e","inverseNode","inverseProperties","pick","Object","inverseMark","inverseSelection","inverseProps","inverseValue","OPERATION_ATTRIBUTES","inverted","invert","json","ATTRIBUTES","toJS","isOperation","Change","editor","operations","tmp","withoutNormalizing","save","newDirtyPaths","getDirtyPaths","dirty","reduce","memo","transformed","fn","normalizeDirtyPaths","command","query","table","getKeysToPathsTable","values","moveToStartOfDocument","normalize","pop","normalizeNodeByPath","iterations","iterate","found","nextPath","previousPath","parentPath","newParentPath","oldAncestors","newAncestors","Commands","PROXY_TRANSFORMS","method","change","methodAtRange","match","moveToStart","moveToEnd","isExpanded","addMarkAtRange","select","delete","deleteAtRange","insertBlock","insertBlockAtRange","moveToEndOfNode","insertFragment","fragment","startText","endText","startInline","lastText","lastInline","firstChild","lastChild","getTexts","isAppending","isAtStartOfNode","isAtEndOfNode","isInserting","hasBlockChildren","insertFragmentAtRange","newTexts","includes","newText","takeLast","insertInline","insertInlineAtRange","getInsertMarksAtRange","insertTextAtRange","removeMarkAtRange","replaceMark","oldMark","splitBlock","depth","splitBlockAtRange","toggleMark","exists","activeMarks","wrapText","prefix","suffix","wrapTextAtRange","isCollapsed","moveStartBackward","moveEndBackward","isForward","flip","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","char","remaining","test","charAt","getCharLength","rest","charCodeAt","getCharOffset","getCharOffsetBackward","reverse","getCharOffsetForward","getWordOffset","started","getWordOffsetBackward","o","getWordOffsetForward","texts","addMarkByKey","addMarksAtRange","snapshotSelection","startKey","endKey","isStartVoid","hasVoidParent","isEndVoid","startBlock","endBlock","isHanging","prevText","startVoid","getClosestVoid","nextText","removeNodeByKey","endVoid","removeTextByKey","startLength","endLength","ancestor","getCommonAncestor","startChild","getFurthestAncestor","endChild","startParent","getParent","startParentIndex","indexOf","endParentIndex","afters","startChildIndex","endChildIndex","middles","befores","lonely","getFurthestOnlyChildAncestor","moveNodeByKey","mergeNodeByKey","deleteCharBackwardAtRange","TextUtils","deleteBackwardAtRange","deleteLineBackwardAtRange","deleteWordBackwardAtRange","voidParent","isVoid","prevBlock","prevVoid","moveFocusBackward","traversed","deleteCharForwardAtRange","deleteForwardAtRange","deleteLineForwardAtRange","deleteWordForwardAtRange","wordOffset","nextBlock","nextVoid","moveFocusForward","extra","insertNodeByKey","atEnd","siblingText","splitRange","splitDescendantsByKey","mapDescendants","isAtStart","blocks","getBlocks","firstBlock","lastBlock","insertionNode","findInsertionNode","lonelyParent","getFurthest","lonelyChild","startIndex","excludingLonelyChild","nextChild","getNextSibling","nextNodes","skipUntil","lastIndex","inlineChild","inlineIndex","hasSingleNode","firstNode","fragmentInner","matches","documentNode","documentInner","assertDescendant","splitNodeByKey","insertTextByKey","removeMarkByKey","setBlocksAtRange","sets","setNodeByKey","setInlinesAtRange","inlines","height","h","isBackward","moveAnchorToStartOfNode","setFocus","resolveRange","splitInlineAtRange","Infinity","toggleMarkAtRange","some","unwrapBlockAtRange","wrappers","getClosest","isSuperset","toList","children","hasDescendant","firstMatch","lastMatch","takeUntil","firstText","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","endIndex","splitText","inlinekey","rng","startInner","startInnerIndex","endInner","startInlines","endInlines","startNode","endNode","startRange","endRange","addMarkByPath","bx","by","ax","ay","applyOperations","insertFragmentByPath","insertNodeByPath","insertTextByPath","getMarksAtIndex","updated","isAtomic","setValue","mergeNodeByPath","previous","getPreviousSibling","moveNodeByPath","removeMarkByPath","removeAllMarksByPath","state","getTextsAsArray","removeNodeByPath","removeTextByPath","from","to","removals","replaceNodeByPath","newNode","replaceTextByPath","createRange","activeMark","setMarkByPath","setNodeByPath","setTextByPath","splitNodeByPath","splitDescendantsByPath","textPath","textOffset","prevIndex","unwrapInlineByPath","moveToRangeOfNode","unwrapBlockByPath","unwrapNodeByPath","parentIndex","grandPath","isFirst","isLast","updatedPath","unwrapChildrenByPath","childIndex","childPath","wrapBlockByPath","wrapInlineByPath","wrapNodeByPath","COMMANDS","assertPath","newKey","textKey","CommandsPlugin","commands","onCommand","call","onConstruct","registerCommand","undos","lastBatch","lastOperation","shouldMerge","batch","withoutSaving","redos","newData","redo","omit","undo","withoutMerging","blur","deselect","proxy","moveAnchorBackward","pointBackward","moveAnchorWordBackward","pointWordBackward","moveAnchorForward","pointForward","moveAnchorWordForward","pointWordForward","moveAnchorToEndOfBlock","pointEdgeObject","moveAnchorToEndOfInline","moveAnchorToEndOfDocument","moveAnchorToEndOfNode","moveToAnchor","moveAnchorToEndOfNextBlock","pointEdgeSideObject","moveAnchorToEndOfNextInline","moveAnchorToEndOfNextText","moveAnchorToEndOfPreviousBlock","moveAnchorToEndOfPreviousInline","moveAnchorToEndOfPreviousText","moveAnchorToEndOfText","moveAnchorToStartOfBlock","moveAnchorToStartOfDocument","moveAnchorToStartOfInline","moveAnchorToStartOfNextBlock","moveAnchorToStartOfNextInline","moveAnchorToStartOfNextText","moveAnchorToStartOfPreviousBlock","moveAnchorToStartOfPreviousInline","moveAnchorToStartOfPreviousText","moveAnchorToStartOfText","moveWordBackward","moveFocusWordBackward","moveToFocus","moveEndWordBackward","moveEndForward","moveEndWordForward","moveEndToEndOfBlock","moveEndToEndOfDocument","moveEndToEndOfNode","moveEndToEndOfInline","moveEndToEndOfNextBlock","moveEndToEndOfNextInline","moveEndToEndOfNextText","moveEndToEndOfPreviousBlock","moveEndToEndOfPreviousInline","moveEndToEndOfPreviousText","moveEndToEndOfText","moveEndToStartOfBlock","moveEndToStartOfDocument","moveEndToStartOfNode","moveEndToStartOfInline","moveEndToStartOfNextBlock","moveEndToStartOfNextInline","moveEndToStartOfNextText","moveEndToStartOfPreviousBlock","moveEndToStartOfPreviousInline","moveEndToStartOfPreviousText","moveEndToStartOfText","moveFocusWordForward","moveFocusToEndOfBlock","moveFocusToEndOfDocument","moveFocusToEndOfNode","moveFocusToEndOfInline","moveFocusToEndOfNextBlock","moveFocusToEndOfNextInline","moveFocusToEndOfNextText","moveFocusToEndOfPreviousBlock","moveFocusToEndOfPreviousInline","moveFocusToEndOfPreviousText","moveFocusToEndOfText","moveFocusToStartOfBlock","moveFocusToStartOfDocument","moveFocusToStartOfNode","moveFocusToStartOfInline","moveFocusToStartOfNextBlock","moveFocusToStartOfNextInline","moveFocusToStartOfNextText","moveFocusToStartOfPreviousBlock","moveFocusToStartOfPreviousInline","moveFocusToStartOfPreviousText","moveFocusToStartOfText","moveWordForward","moveStartWordBackward","moveStartForward","moveStartWordForward","moveStartToEndOfBlock","moveStartToEndOfDocument","moveStartToEndOfNode","moveStartToEndOfInline","moveStartToEndOfNextBlock","moveStartToEndOfNextInline","moveStartToEndOfNextText","moveStartToEndOfPreviousBlock","moveStartToEndOfPreviousInline","moveStartToEndOfPreviousText","moveStartToEndOfText","moveStartToStartOfBlock","moveStartToStartOfDocument","moveStartToStartOfNode","moveStartToStartOfInline","moveStartToStartOfNextBlock","moveStartToStartOfNextInline","moveStartToStartOfNextText","moveStartToStartOfPreviousBlock","moveStartToStartOfPreviousInline","moveStartToStartOfPreviousText","moveStartToStartOfText","moveToEndOfBlock","moveToEndOfDocument","moveToEndOfInline","moveToEndOfNextBlock","moveToEndOfNextInline","moveToEndOfNextText","moveToEndOfPreviousBlock","moveToEndOfPreviousInline","moveToEndOfPreviousText","moveToEndOfText","moveToRangeOfDocument","moveToStartOfBlock","moveToStartOfInline","moveToStartOfNextBlock","moveToStartOfNextInline","moveToStartOfNextText","moveToStartOfPreviousBlock","moveToStartOfPreviousInline","moveToStartOfPreviousText","moveToStartOfText","snapshot","k","setAnchor","setEnd","setStart","edge","toUpperCase","Edge","side","Side","getDirectionNode","isInBlock","isPreviousInVoid","isNextInVoid","pointName","QueriesPlugin","queries","registerQuery","onQuery","ret","SlateError","captureStackTrace","constructor","stack","SchemaPlugin","schema","rules","schemaRules","rule","testRules","normalizeNode","error","validateNode","failure","validateRules","Queries","defaultNormalize","validateObject","validateType","validateData","validateMarks","validateText","validateFirst","validateLast","validateNodes","fail","valid","def","replace","defs","nextDef","shift","rewind","err","validateParent","validatePrevious","validateNext","CorePlugin","plugins","AtCurrentRange","AtRange","ByPath","OnHistory","OnSelection","OnValue","Schema","Editor","onChange","readOnly","AbstractChange","middleware","core","run","setReadOnly","isChanging","obj","handler","event","overrides","defineProperty","registerPlugin","plugin","commandsPlugin","queriesPlugin","schemaPlugin","mixin","Interface","Classes","Class","getOwnPropertyNames","name","hasOwnProperty","desc","getOwnPropertyDescriptor","TYPE","camel","ObjectInterface","bind","ModelInterface","NodeInterface","descendant","nested","dict","normalizer","getText","ElementInterface","replaceNode","resolvePoint","forEachDescendant","getMarksAtPosition","toSet","getActiveMarksBetweenOffsets","startMarks","endMarks","current","getBlocksAsArray","isLeafBlock","getBlocksAtRangeAsArray","getBlocksByTypeAsArray","closest","startAt","deep","flatMap","targetPath","targetPosition","mode","furthest","getInlinesAsArray","isLeafInline","getInlinesAtRangeAsArray","getTextsAtRangeAsArray","getInlinesByTypeAsArray","currentMarks","closestBlock","getOrderedMarksAtRange","getMarksByTypeAsArray","sibling","getNextNode","hasChild","getOrderedMarksBetweenPositions","getMarksBetweenOffsets","getTextsBetweenPositionsAsArray","getPreviousNode","isSelected","dir","direction","getChild","mergeText","deleteIn","ASSERTS","RangeInterface","setPoints","updater"],"mappings":"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"}